name: Check File Action
description: 'Check file - Add filename to check for errors or text Word to search for within workspace files'
inputs:
  filename:
    description: 'Check for filename or search for text word matches'
    type: string
    required: false
    default: ''
  filetype:
    description: 'Check only these file extension types when searching for text word matches'
    type: string
    required: false
    default: 'none'
  filetext:
    description: 'Search for text string matches in selected or all files'
    type: string
    required: false
    default: ''
  dirname:
    description: 'Your project root folder if created'
    type: string
    required: false
    default: ''
  rootdir:
    description: 'Search will start from root (/) if true'
    type: boolean
    required: false
    default: 'false'
  content:
    description: 'Search will list dir contents of found filename if true'
    type: boolean
    required: false
    default: 'false'
  include:
    description: 'Check include files called by C/C++ filename searches if true'
    type: boolean
    required: false
    default: 'false'
  recheck:
    description: 'Recheck files repaired by repair if true'
    type: boolean
    required: false
    default: 'false'
  repair:
    description: 'Check file and fix if able when searching for errors'
    type: boolean
    required: false
    default: 'false'
  report:
    description: 'Errors found will be logged and sent to repo releases if true'
    type: boolean
    required: false
    default: 'false'
  update:
    description: 'Errors repaired with clang-tidy push changes to remote repo if true'
    type: boolean
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Set up Go 1.25.3
      if: inputs.filename != ''
      uses: actions/setup-go@v2 
      with: 
        go-version: 1.25.3


    - name: Installing Dependencies
      if: inputs.filetext != '' || inputs.filename != ''
      run: |
        set -o allexport
        export GIT_DISCOVERY_ACROSS_FILESYSTEM=1
        export DEBIAN_FRONTEND=noninteractive
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file=$(sudo find ${GITHUB_WORKSPACE} -type f -name "checkmake.ini" -print -quit);
        path='/home/runner/checkmake.ini';
        sudo apt-get autoclean >/dev/null 2>&1;
        sudo apt-get autoremove >/dev/null 2>&1;
        echo 'deb [trusted=yes] https://apt.gabe565.com /' | sudo tee /etc/apt/sources.list.d/gabe565.list;
        sudo apt-get update -yq >/dev/null 2>&1;
        sudo apt-get upgrade -yq >/dev/null 2>&1;
        sudo add-apt-repository universe >/dev/null;
        sudo add-apt-repository ppa:git-core/ppa >/dev/null;

        if [[ ! $(which git) ]]; then
          sudo apt-get -yq install git >/dev/null && echo -e "\n####################\n\t.Git dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which ansi2txt) ]]; then
          sudo apt-get -yq install ansi2txt >/dev/null && echo -e "\n####################\n\tAnsi2txt dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which update-ca-certificates) ]]; then
          sudo apt-get -yq install ca-certificates >/dev/null && echo -e "\n####################\n\tCa-certificates dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which cppcheck) ]] && [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          sudo apt-get -yq install cppcheck >/dev/null && echo -e "\n####################\n\tCppcheck dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which clang-tidy) ]] && [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          sudo apt-get -yq install clang-tidy clang-format >/dev/null && echo -e "\n####################\n\Clang-tool dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which shellharden) ]] && [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          wget -qO shellharden.tar.gz https://github.com/anordal/shellharden/releases/latest/download/shellharden-x86_64-unknown-linux-gnu.tar.gz
          sudo tar xf shellharden.tar.gz -C /usr/local/bin shellharden && rm -vrf shellharden.tar.gz && echo -e "\n####################\n\tShellharden dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which shellcheck) ]] && [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          sudo apt-get -yq install shellcheck >/dev/null && echo -e "\n####################\n\tShellcheck dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which checkmake) ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          go install "github.com/checkmake/checkmake/cmd/checkmake@latest" >/dev/null && echo -e "\n####################\n\tCheckmake dependencies Installed\n####################\n";     
          if [[ -n ${file} ]]; then
            echo -e "\n####################\n\tcheckmake.ini found copying...\n####################\n";
            sudo cp -vf "${file}" "${path}" 2>/dev/null;
          fi;
        elif [[ -n ${file} ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          sudo cp -vf "${file}" "${path}" 2>/dev/null;
        fi;

        if [[ $(which bat) ]] && [[ ! $(which batcat) ]]; then
          sudo ln -sf ~/usr/bin/bat ~/usr/bin/batcat >/dev/null 2>&1;
          echo "########## $(which batcat) ##########" || echo "No batcat found Exiting... $(exit 1)";
          sudo bash -c echo -e "\nalias batcat='bat'" >> ~/.bashrc 2>/dev/null;
          export BAT_THEME="ansi";
        elif [[ ! $(which batcat) ]]; then
          sudo apt-get -yq install bat >/dev/null && echo -e "\n####################\n\tBatcat dependencies Installed\n####################\n";
          echo "########## $(which batcat) ##########" || echo "No batcat found Exiting... $(exit 1)";
          export BAT_THEME="ansi";
        fi;

        sudo apt-get --fix-broken install -yq >/dev/null 2>&1;
      shell: bash
      continue-on-error: false


    - name: Search Directory Base
      if: inputs.filetext != '' || inputs.filename != ''
      id: set_dirname 
      env: 
        DEFAULT_PATH: "*" 
      run: |
        echo ''
        if ${{ inputs.rootdir }}; then
          echo -e "\n####################\nNOTE: Default directory ( ~/ )\n####################\n";
          echo "FILE_PATH=/" >> "${GITHUB_ENV}";
        else
          echo -e "\n####################\nNOTE: Default directory ( ${GITHUB_WORKSPACE} )\n####################\n";
          echo "FILE_PATH=${GITHUB_WORKSPACE}" >> "${GITHUB_ENV}";
        fi;

        if [[ "${{ inputs.filename }}" != '' ]]; then
          echo -e "\n####################\nSearching directories for ${{ inputs.filename }} file(s)\n####################\n";
        fi;

        if [[ "${{ inputs.filetext }}" != '' ]] && [[ ${{ inputs.filetype }} != 'none' ]]; then
          echo -e "\n####################\nSearching ${{ inputs.filetype }} files for ${{ inputs.filetext }} match(s)\n####################\n";
        elif [[ "${{ inputs.filetext }}" != '' ]]; then
          echo -e "\n####################\nSearching all files for ${{ inputs.filetext }} match(s)\n####################\n";
        fi;
      
        if [[ "${{ inputs.dirname }}" == '' ]]; then
          if [ -z "${{ github.event.inputs.DEVICE_PATH }}" ]; then 
            echo "dirname=${{ env.DEFAULT_PATH }}" >> "$GITHUB_OUTPUT";
          else 
            echo "dirname=${{ github.event.inputs.DEVICE_PATH }}" >> "$GITHUB_OUTPUT";
          fi;
        else
          echo "dirname=${{ inputs.dirname }}" >> "$GITHUB_OUTPUT";
        fi;

        echo "FILE_FOUND=0" >> "${GITHUB_ENV}";
        echo "FILE_ERROR=0" >> "${GITHUB_ENV}";
      shell: bash
      continue-on-error: false


    - name: Check & Repair (Clang-tools)
      if: inputs.filename != ''
      run: |
        echo ''
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_path=$(sudo find ${{ env.FILE_PATH }} -type f -name '.clang-tidy' -print -quit);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        clang_file=${GITHUB_WORKSPACE}/.clang-tidy;
        repair=${GITHUB_WORKSPACE}/repair-generated.txt;
        count2=0
        file_count=1
        include_count=1
        if [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && [[ -n ${files} ]]; then
          set -o pipefail
          echo -e "\n####################\nWorkspace-folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          if [[ -f "${file_path}" ]] && ${{ inputs.repair }}; then
            echo -e "\n####################\n\t.clang-tidy found copying...\n####################\n";
            sudo cp -vf "${file_path}" "${clang_file}";
          fi;
          echo -e "\n# Found File Path(s)\n${files}\n\n";
          for f in ${files[@]}; do
            count1=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count1})\n####################\n";
            echo "$(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
            if ${{ inputs.content }} && ! ${{ inputs.include }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count1})\n####################\n";
              sudo find $(dirname ${f}) -type f -name $(basename ${f}) -exec batcat --theme=ansi --paging=never --show-all --color=always --style=full "{}" \;
            fi;
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -n ${includes} ]]; then
                echo -e "\n# Found Include File(s):\n${includes}\n";
                include_paths='';
                separator=' -I';
                for i in ${includes[@]}; do
                  final="${i}";
                  count2=$((include_count++));
                  header=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/$(dirname ${i})/*" -o -path "${{ steps.set_dirname.outputs.dirname }}" \) -name "$(basename ${i})" -print -quit);
                  for h in ${header[@]}; do
                    echo "$(dirname ${h/\\n /})" >> "$(dirname ${f})/${included1}";
                    include_paths+="${separator/\\n /}$(dirname ${h/\\n /})";
                  done;
                done;
                if [[ -f "$(dirname ${f})/${included1}" ]]; then
                  awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                fi;
                if [[ -n ${header} ]] && [[ -n ${include_paths} ]]; then
                  if ${{ inputs.content }}; then
                    included3=$(dirname ${f})/${included2}
                    echo -e "\n####################\n\tFILE PATH(S) (${count2})\n####################\n";
                    batcat --theme=ansi --paging=never --show-all --color=always --style=full "${included3}";
                  fi;
                  if ${{ inputs.repair }}; then
                    echo "${f}" >> "${repair}";
                    echo -e "\n\n####################\nCLANG-TIDY INCLUDE FILES ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths/\\n /}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  else
                    echo -e "\n\n####################\nCPPCHECK INCLUDE FILE(S) ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 --includes-file="${included3}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  fi;
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                else 
                  echo -e "\n\n####################\nHEADER FILE(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              else
                echo -e "\n\n####################\nINCLUDE FILE(S) FOR $(basename ${f}) NOT PRESENT\n####################\n\n";
              fi;
            else
              if ${{ inputs.repair }}; then
                echo "${f}" >> "${repair}";
                echo -e "\n\n####################\nCLANG-TIDY ERROR ANALYZER (${count1})\n####################\n\n";
                clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes --quiet -- -I$(echo $(dirname ${f}) | cut -d/ -f1-7) |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              else
                echo -e "\n\n####################\nCPPCHECK FILE ANALYZER (${count1})\n####################\n\n";
                cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              fi;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if ${{ inputs.recheck }} && ${{ inputs.repair }}; then
              echo -e "\n\n####################\nCPPCHECK RE-ANALYZING FILE(S) (${count1})\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nRECHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nRECHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if [[ -f "$(dirname ${f})/${included2}" ]]; then
              echo -e "# Included Path(s): ${include_paths/\\n /}";
              echo -e "\nInclude_File: $(rm -vf $(dirname ${f})/${included1})\n" 2>/dev/null;
              echo -e "\nInclude_Path: $(rm -vf $(dirname ${f})/${included2})\n" 2>/dev/null;
            fi;
          done;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count1}\n";
          echo -e "Total number of included file(s) checked is: ${count2}\n";
          echo -e "Scanning Completed!\nCheck-file Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING C/C++ FILE TYPES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Shell Files
      if: inputs.filename != '' && env.FILE_FOUND == 0 
      run: |
        echo ''
        repair=${GITHUB_WORKSPACE}/repair-generated.txt;
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        shellcheck_count=1
        if [[ -n $(echo "${file_type}" | grep -i "^sh$") ]] && [[ -n ${files} ]]; then
          set -o pipefail
          echo -e "\n####################\nWorkspace-folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count3=$((shellcheck_count++));
            echo -e "\n####################\n\tFILE PATH (${count3})\n####################\n";
            echo "$(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.repair }}; then
              SHELL=SHELLHARDEN
              echo -e "\n\n####################\nSHELLHARDEN ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" && file_error=1;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S) TO FIX\n####################\n";
              fi;
            fi;
            if ${{ inputs.recheck }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || file_error=1;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            elif ! ${{ inputs.repair }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || file_error=1;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            fi;
          done;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count3\n";
          echo -e "Scanning Completed!\nShellTools Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING SH FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Makefile Files
      if: inputs.filename != '' && env.FILE_FOUND == 0
      run: |
        echo ''
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        makefile_count=1
        if [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]] && [[ -n ${files} ]]; then
          set -o pipefail
          echo -e "\n####################\nWorkspace-folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count4=$((makefile_count++));
            echo -e "\n####################\n\tFILE PATH (${count4})\n####################\n";
            echo "$(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || >/dev/null;
            if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND ${f}\n####################\n";
            else
              echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            fi;
          done;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count4\n";
          echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING MK FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check All Files
      if: inputs.filename != '' && env.FILE_FOUND == 0 
      run: |
        echo ''
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file_count=1
        if [[ -n ${files} ]]; then
          set -o pipefail
          echo -e "\n####################\nWorkspace-folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count5=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count5})\n####################\n";
            echo "$(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count5})\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
          done;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count5}\n";
          echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
        else
          echo -e "\n####################\nFINISHED SEARCHING ALL FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Word Text Match
      if: inputs.filetext != ''
      run: |
        echo ''
        file_count=1
        set -o pipefail
        echo -e "\n####################\nWorkspace-folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
        if [[ ${{ inputs.filetype }} != 'none' ]]; then
          for t in ${{ inputs.filetype }}; do
            finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -Hans "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
            content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -q "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
            if [[ -n ${finder} ]]; then
              counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
              echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S)\n####################\n";
              echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                  echo -e "\n$(dirname ${c})\n":
                  echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                  batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                  echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
            fi;
          done;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        else
          finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -Hans "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
          content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -q "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
          if [[ -n ${finder} ]]; then
            counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
            echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN FILE(S)\n####################\n";
            echo -e "\n${finder}\n";
            if ${{ inputs.content }}; then
              for c in ${content[@]}; do
                count=$((file_count++));
                echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                echo -e "\n$(dirname ${c})\n":
                echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                echo -e "\n####################\nFILE COMPLETED\n####################\n";
              done;
            fi;
          else
            echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
          fi;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Directory Contains
      if: inputs.filename != '' && inputs.content != 'false'
      run: |
        echo ''
        file_count=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) | wc -l);
        if [[ ${{ env.FILE_FOUND }} != 0  ]]; then
          echo -e "\n####################\nNOTE: Contents found in directory(s) for ${{ inputs.filename }}\n####################\n";
          ls -Shap $(dirname $(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}"));
          echo -e "\n(LOCAL REPO) Files: ${file_count}\n";
          echo -e "\n####################\nCHECK FILE EXITING ....✅\n####################";
        fi;
      shell: bash
      continue-on-error: true

      
    - name: Repository Update
      if: inputs.filename != '' && inputs.update != 'false' && inputs.repair != 'false'
      id: pushed-files
      run: |
        echo ''
        set -o pipefail
        BUILD_DATE="$(date +%Y%m%d)";
        repair=${GITHUB_WORKSPACE}/repair-generated.txt;
        repo=$(sudo find ${GITHUB_WORKSPACE} -type d -name ".git" -print -quit);
        if [[ -d ${repo} ]]; then
          cd "${repo%/*}";
          if [[ -f ${repair} ]]; then 
            sudo mv -f "${repair}" "repaired-${BUILD_DATE}.txt";
          fi;
          git config --global user.name "${{ github.actor }}";
          git config --global user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com";
          git config --global credential.helper store
          git add .
          git commit -m "check-file-action repaired errors in ${{ inputs.filename }} file(s)";
          echo "pushed_files=$(git push | xargs)" >> "${GITHUB_OUTPUT}";
          if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
            echo -e "\n####################\nCHECK FILE UPDATED REPO FILE(S) .. Goodbye\n####################";
          else
            echo -e "\n####################\nCHECK FILE CANT UPDATED REPO FILE(S)\n####################";
          fi;
        else
          echo -e "\n####################\nCHECK FILE CANT FIND (.git) FOR UPDATING\n####################";
        fi;
      shell: bash
      continue-on-error: false


    - name: Get Changed Files
      if: inputs.filename != '' && inputs.update != 'false'
      id: changed-files
      run: |
        echo ''
        set +e
        if ${{ steps.pushed-files.outputs.pushed_files }}; then
          if ${{ github.event_name == 'workflow_dispatch' }}; then 
            echo "changed_files=$(git diff --name-only -r HEAD^1 HEAD | xargs)" >> "${GITHUB_OUTPUT}";
          else
            echo "changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} | xargs)" >> "${GITHUB_OUTPUT}";
          fi;
        fi;
      shell: bash
      continue-on-error: false


    - name: List Changed Files
      if: inputs.filename != '' && inputs.update != 'false' && inputs.report != 'false'
      run: |
        echo ''
        if ${{ steps.changed-files.outputs.changed_files }}; then
          for file in ${{ steps.changed-files.outputs.changed_files }}; do
            echo -e "$file was repaired" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
          done;
        fi;
      shell: bash
      continue-on-error: false


    - name: Check For ${{ inputs.filename }} Error.log
      if: inputs.report != 'false' && inputs.filename != ''
      run: |
        echo ''
        if [[ -s "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" ]]; then
          echo "FILE_ERROR=1" >> "${GITHUB_ENV}";
          ansi2txt "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" > "${GITHUB_WORKSPACE}/${{ inputs.filename }}_new_error.log" &&
          sudo mv -f "${GITHUB_WORKSPACE}/${{ inputs.filename }}_new_error.log" "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log"
        fi;
      shell: bash
      continue-on-error: true


    - name: Uploading ${{ inputs.filename }} Error Report
      if: inputs.report != 'false' && inputs.filename != '' && env.FILE_ERROR == 1
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./${{ inputs.filename }}_error.log
        name: Check File Action Errors Report For ${{ inputs.filename }} File(s).
        tag_name: ${{ github.run_id }}


    - name: Delete Log File
      if: inputs.filename != ''
      run: |
        date
        if [[ -f "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" ]]; then
          echo -e "\nLOGFILE: $(rm -vf ${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log)\n";
        fi;
      shell: bash
      continue-on-error: false


    - name: Filename Check
      if: inputs.filename == '' && inputs.filetext == ''
      run: |
        echo ''
        echo -e "\nNo input provided!\nVariables not set\n• filename\n• filetext\n\t Exiting\n";
      shell: bash
      continue-on-error: false

## version v2.0.0