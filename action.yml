name: Check File Action
description: 'Check file - Add filename to check for errors or text Word to search for within workspace files'
inputs:
  analysis:
    description: 'Analyze all project files using options 1 2 or 3'
    required: false
    default: 1
    type: choice
    options:
    - 1 # uses clang_tidy_params.txt for smaller simple repos.
    - 2 # uses run-clang-tidy.py for parallelism of file scanning.
    - 3 # uses compile_commands.json for maximum project build scans.
  filename:
    description: 'Check for filename or search for text word matches'
    type: string
    required: false
    default: ''
  filetype:
    description: 'Check only these file extension types when searching for text word matches'
    type: string
    required: false
    default: 'none'
  database:
    description: 'Use file database over find commands slower performance for searches'
    type: boolean 
    required: false
    default: 'false'
  dirname:
    description: 'Your project root folder if created'
    type: string
    required: false
    default: ''
  pattern:
    description: 'Search for pattern matches in filetypes or all files'
    type: string
    required: false
    default: ''
  project:
    description: 'Fix Errors found while building project or check build only'
    type: boolean
    required: false
    default: 'false'
  rootdir:
    description: 'Search will start from root (/) if true'
    type: boolean
    required: false
    default: 'false'
  recheck:
    description: 'Recheck files repaired by check-file'
    type: boolean
    required: false
    default: 'false'
  repair:
    description: 'Check file and fix if able when searching for errors'
    type: boolean
    required: false
    default: 'false'
  report:
    description: 'Errors found will be logged and sent to repository releases'
    type: boolean
    required: false
    default: 'false'
  compiler:
    description: 'Clang compiler used for project building only'
    type: string
    required: false
    default: 'clang-19.1.0'
  content:
    description: 'Search will list dir contents of found filename'
    type: boolean
    required: false
    default: 'false'
  include:
    description: 'Check include files called by C/C++ filename searches if true'
    type: boolean
    required: false
    default: 'false'
  number:
    description: 'Number of files to check before stopping action'
    type: number
    required: false
    default: 0
  stored:
    description: 'Check files with errors repaired are skipped if ran again'
    type: boolean
    required: false
    default: 'false'
  update:
    description: 'Errors repaired with check-file will push changes to remote repository'
    type: boolean
    required: false
    default: 'false'
  build:
    description: 'Fix Errors found while building repository project'
    type: boolean
    required: false
    default: 'false'

runs:
  using: composite
  steps:

    - name: Set up Go 1.25.3
      if: inputs.filename != ''
      uses: actions/setup-go@v2
      with:
        go-version: 1.25.3
      continue-on-error: true


    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
      continue-on-error: true


    - name: Setup Clang Compiler 
      if: inputs.project == 'true'
      uses: rlalik/setup-cpp-compiler@master
      with:
        compiler: ${{ inputs.compiler }}
      continue-on-error: true


    - name: Installing Dependencies
      if: inputs.pattern != '' || inputs.filename != '' || inputs.project != 'false'
      run: |
        echo '';
        set -o pipefail
        echo 'export GIT_DISCOVERY_ACROSS_FILESYSTEM=1' | sudo tee -a ~/.bashrc >/dev/null;
        echo 'export DEBIAN_FRONTEND=noninteractive' | sudo tee -a ~/.bashrc >/dev/null;
        echo 'export TERM=xterm-256color' | sudo tee -a ~/.bashrc;
        echo 'deb [trusted=yes] https://apt.gabe565.com /' | sudo tee -a /etc/apt/sources.list.d/gabe565.list;
        sudo add-apt-repository universe >/dev/null;
        sudo add-apt-repository ppa:git-core/ppa >/dev/null;
        text0="\n####################\ngit dependencies Installed\n####################\n";
        text1="\n####################\nripgrep dependencies Installed\n####################\n";
        text2="\n####################\nansi2txt dependencies Installed\n####################\n";
        text3="\n####################\nca-certificates dependencies Installed\n####################\n";
        text4="\n####################\ncppcheck dependencies Installed\n####################\n";
        text5="\n####################\nclang-tools dependencies Installed\n####################\n";
        text6="\n####################\nshellharden dependencies Installed\n####################\n";
        text7="\n####################\nshellcheck dependencies Installed\n####################\n";
        text8="\n####################\ncheckmake dependencies Installed\n####################\n";
        text9="\n####################\ncheckmake.ini found copying\n####################\n";
        text10="\n####################\nbatcat dependencies Installed\n####################\n";
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        file=$(sudo find ${GITHUB_WORKSPACE} -type f -name "checkmake.ini" -print -quit);
        path='/home/runner/checkmake.ini';

        if [[ ! -n $(clang-tidy --version 2>/dev/null) ]] && ([[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && ${{ inputs.repair }}) || ${{ inputs.project }}; then
          wget -qO - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - >/dev/null;
          sudo add-apt-repository "deb http://apt.llvm.org/$(lsb_release -cs)/ llvm-toolchain-$(lsb_release -cs)-17 main" >/dev/null;
          sudo apt-get update -yq >/dev/null 2>&1;
          sudo apt-get install -yq clang clangd clang-tools >/dev/null && echo -e "${text5}" || echo 'No clang-tools installed Exiting';
          [[ ! -n $(clang-tidy --version 2>/dev/null) ]] && exit 1
        else
          sudo apt-get update -yq >/dev/null 2>&1;
        fi;

        if [[ ! $(llvm-config --version 2>/dev/null) ]] && ${{ inputs.project }}; then
          sudo apt-get -yq install llvm llvm-dev lld libclang-dev >/dev/null && echo -e "\n####################\nllvm tools dependencies Installed\n####################\n" || echo 'No llvm tools installed for project build';
          [[ ! $(llvm-config --version 2>/dev/null) ]] && exit 1
        fi;

        if [[ ! -n $(dpkg -s build-essential 2>/dev/null) ]] && ${{ inputs.project }}; then
          sudo apt-get -yq install build-essential device-tree-compiler >/dev/null && echo -e "\n####################\nbuild-essential dependencies Installed\n####################\n" || echo 'No build-essential installed for project build';
        fi;

        if [[ ! $(which ninja) ]] && ${{ inputs.project }}; then
          sudo apt-get -yq install ninja-build >/dev/null && echo -e "\n####################\nninja dependencies Installed\n####################\n" || echo 'No ninja installed for project build';
          [[ ! $(which ninja) ]] && exit 1
        fi;

        if [[ ! $(which cmake) ]] && ${{ inputs.project }}; then
          sudo apt-get -yq install cmake >/dev/null >/dev/null && echo -e "\n####################\ncmake dependencies Installed\n####################\n" || echo 'No cmake installed for project build';
          [[ ! $(which cmake) ]] && exit 1
        fi;

        if [[ ! $(which python3) ]] && ${{ inputs.project }} && ${{ inputs.analysis == 2 }}; then
          sudo apt-get -yq install python3 >/dev/null >/dev/null && echo -e "\n####################\npython3 dependencies Installed\n####################\n" || echo 'No python3 installed for project build';
          [[ ! $(which python3) ]] && exit 1
        fi;

        if [[ ! $(which npm) ]]; then
          sudo npm install >/dev/null && echo -e "\n####################\nnpm dependencies Installed\n####################\n" || echo 'No npm installed for term_width';
          [[ ! $(which tput) ]] && exit 1
        fi;

        if [[ ! $(which tput) ]]; then
          sudo apt-get -yq install tput >/dev/null && echo -e "\n####################\ntput dependencies Installed\n####################\n" || echo 'No tput installed for term_width';
          [[ ! $(which tput) ]] && exit 1
        fi;

        if [[ ! $(which git) ]]; then
          sudo apt-get -yq install git git-core >/dev/null && echo -e "${text0}" || echo 'No git installed for repo updates';
          [[ ! $(which git) ]] && exit 1
        fi;

        if [[ ! $(which rg) ]] && [[ "${{ inputs.pattern }}" != '' ]] && ${{ inputs.database }}; then
          sudo apt-get -yq install ripgrep >/dev/null && echo -e "${text1}" || echo 'No ripgrep installed for pattern matching';
          [[ ! $(which rg) ]] && exit 1
        fi;

        if [[ ! $(which ansi2txt) ]] && ${{ inputs.report }}; then
          sudo apt-get -yq install ansi2txt >/dev/null && echo -e "${text2}" || echo 'No ansi2txt installed for cleaning log report';
        fi;

        if [[ ! $(which update-ca-certificates) ]]; then
          sudo apt-get -yq install ca-certificates >/dev/null && echo -e "${text3}" || echo 'No ca-certificates installed effects can vary';
        fi;

        if [[ ! $(which cppcheck) ]] && [[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          sudo apt-get -yq install cppcheck >/dev/null && echo -e "${text4}" || echo 'No cppcheck installed Exiting';
          [[ ! $(which cppcheck) ]] && exit 1
        fi;

        if [[ ! $(which shellharden) ]] && [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]] && ${{ inputs.repair }}; then
          wget -qO 'shellharden.tar.gz' 'https://github.com/anordal/shellharden/releases/latest/download/shellharden-x86_64-unknown-linux-gnu.tar.gz';
          sudo tar xf 'shellharden.tar.gz' -C '/usr/local/bin' 'shellharden' && rm -vrf 'shellharden.tar.gz' && echo -e "${text6}" || echo 'No shellharden installed Exiting';
          [[ ! $(which shellharden) ]] && exit 1
        fi;

        if [[ ! $(which shellcheck) ]] && [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]]; then
          sudo apt-get -yq install shellcheck >/dev/null && echo -e "${text7}" || echo 'No shellcheck installed Exiting';
          [[ ! $(which shellcheck) ]] && exit 1
        fi;

        if [[ ! $(which checkmake) ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          go install "github.com/checkmake/checkmake/cmd/checkmake@latest" >/dev/null && echo -e "${text8}" || echo 'No checkmake installed Exiting';
          [[ ! $(which checkmake) ]] && exit 1
          if [[ -n ${file} ]]; then
            echo -e "${text9}";
            sudo cp -vf "${file}" "${path}" 2>/dev/null;
          fi;
        elif [[ -n ${file} ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          sudo cp -vf "${file}" "${path}" 2>/dev/null;
        elif [[ ! -n ${file} ]]; then
          echo -e '\ncheckmake.ini file missing, needed for checkmake to function properly\n';
        fi;

        if [[ $(which bat) ]] && [[ ! $(which batcat) ]]; then
          sudo ln -sf ~/usr/bin/bat ~/usr/bin/batcat >/dev/null || echo 'No batcat installed Exiting';
          [[ ! $(which batcat) ]] && exit 1
          echo -e "\nalias batcat='bat'" | sudo tee -a ~/.bashrc >/dev/null;
          export BAT_THEME="ansi";
        elif [[ ! $(which batcat) ]]; then
          sudo apt-get -yq install bat >/dev/null && echo -e "${text10}" || echo 'No batcat installed Exiting';
          [[ ! $(which batcat) ]] && exit 1
          export BAT_THEME="ansi";
        fi;

        echo 'update=${{ inputs.update }}' >> "${GITHUB_ENV}";
        sudo apt-get --fix-broken install -yq >/dev/null 2>&1;
      shell: bash
      continue-on-error: false

    
    - name: Set Directory Base
      if: inputs.pattern != '' || inputs.filename != '' || inputs.project != 'false'
      id: set_dirname 
      env: 
        default_path: "*" 
      run: |
        echo '';
        repair_file='check-file-repaired.txt';
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name '.git' -print -quit);
        text1a="####################";
        text1b="DEFAULT DIRECTORY (SYSTEM ROOT)";
        text1c="####################";
        text2a="####################";
        text2b="DEFAULT DIRECTORY (GITHUB WORKSPACE)";
        text2c="####################";
        text3a="####################";
        text3b="Store repaired files Enabled";
        text3c="####################";
        text4="Creating ${repair_file} for checked files";
        text5a="####################";
        text5b="Database Performance Mode Enabled";
        text5c="####################";
        text6="Database not found exiting"
        text7a="####################";
        text7b="Searching directories for $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s)";
        text7c="####################";
        text8a="####################";
        text8b="Searching ${{ inputs.filetype }} files for ${{ inputs.pattern }} match(s)";
        text8c="####################";
        text9a="####################";
        text9b="Searching all files for $(echo ${{ inputs.pattern }} | sed 's/[\/\$]//g') match(s)";
        text9c="####################";
        text10a="#####################";
        text10b="# CHECK FILE ACTION #";
        text10c="#####################";
        export TERM=xterm-256color

        if [[ -n ${TERM} ]]; then
          center_text() {
            local text="$1";
            local term_cols="$(tput cols)";
            local text_length="${#text}";
            if [[ -n $(node ./scripts/mobile.js 2>/dev/null) ]] || [[ -n $(node ./scripts/view.js 2>/dev/null) ]]; then
              local padding="$(( (term_cols - text_length) / 2 ))";
              local text="$(echo $1 | tr -d '\n')";
              print '';
              printf "%*s%s\n" "${padding}" "" "${text}"
              print '';
            else
              echo -e "${text}"
            fi;
          }
        fi;

        if ${{ inputs.rootdir }}; then
          center_text "\n${text1a}";
          center_text "${text1b}";
          center_text "${text1c}";
          echo -e '\n~/\n';
          echo 'file_path=/' >> "${GITHUB_ENV}";
          file_path=/
        else
          center_text "\n${text2a}";
          center_text "${text2b}";
          center_text "${text2c}";
          echo -e "\n${GITHUB_WORKSPACE}\n";
          echo "file_path=${GITHUB_WORKSPACE}" >> "${GITHUB_ENV}";
          file_path=${GITHUB_WORKSPACE}
        fi;

        if ${{ inputs.stored }} && ${{ env.update }} && [[ -d ${repository} ]]; then
          repository="${repository%/*}/${repair_file}";
          if [[ -f ${repository} ]]; then
            center_text "\n${text3a}";
            center_text "${text3b}";
            center_text "${text3c}\n";
          else
            center_text "\n${text4a}";
            center_text "${text4b}";
            center_text "${text4c}\n";
            date '+%Y%m%d' > "${repository}" || exit 1
          fi;
        elif ${{ inputs.stored }} && [[ -d ${repository} ]]; then
          repository="${repository%/*}/${repair_file}";
          if [[ -f ${repository} ]]; then
            center_text "\n${text3a}";
            center_text "${text3b}";
            center_text "${text3c}\n";
          else
            center_text "\n${text4a}";
            center_text "${text4b}";
            center_text "${text4c}\n";
            date '+%Y%m%d' > "${repository}" || exit 1
          fi;
          echo 'update=true' >> "${GITHUB_ENV}";
        fi;

        if ${{ inputs.database }}; then
          sudo find "${file_path}" -type f -print > "${GITHUB_WORKSPACE}/database";
          if [[ -f "${GITHUB_WORKSPACE}/database" ]]; then
            center_text "\n${text5a}";
            center_text "${text5b}";
            center_text "${text5c}\n";
            echo "database=${GITHUB_WORKSPACE}/database" >> "${GITHUB_ENV}";
          else
            center_text "\n${text6a}";
            center_text "${text6b}";
            center_text "${text6c}\n" && exit 1
          fi;
        fi;

        if [[ "${{ inputs.filename }}" != '' ]]; then
          center_text "\n${text7a}";
          center_text "${text7b}";
          center_text "${text7c}\n";
        fi;

        if [[ "${{ inputs.pattern }}" != '' ]] && [[ "${{ inputs.filetype }}" != 'none' ]]; then
          center_text "\n${text8a}";
          center_text "${text8b}";
          center_text "${text8c}\n";
        elif [[ "${{ inputs.pattern }}" != '' ]]; then
          center_text "\n${text9a}";
          center_text "${text9b}";
          center_text "${text9c}\n";
        fi;
      
        if [[ "${{ inputs.dirname }}" == '' ]]; then
          if [ -z "${{ github.event.inputs.DEVICE_PATH }}" ]; then 
            echo "dirname=${{ env.default_path }}" >> "$GITHUB_OUTPUT";
          else 
            echo "dirname=${{ github.event.inputs.DEVICE_PATH }}" >> "$GITHUB_OUTPUT";
          fi;
        else
          echo "dirname=${{ inputs.dirname }}" >> "$GITHUB_OUTPUT";
        fi;
        
        center_text "\n${text10a}" 2>/dev/null;
        center_text "${text10b}" 2>/dev/null;
        center_text "${text10c}\n" 2>/dev/null;
        echo '';
        echo 'file_fixed=0' >> "${GITHUB_ENV}";
        echo 'file_found=0' >> "${GITHUB_ENV}";
        echo 'file_error=0' >> "${GITHUB_ENV}";
      shell: bash
      continue-on-error: false


    - name: Check & Repair (Clang-tools)
      if: inputs.filename != '' && inputs.database != 'false'
      run: |
        export LC_ALL=C
        set -o pipefail
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        if [[ -n $(echo "${{ inputs.filename }}" | sed 's/[\/\$]//g' | grep -Po "\b\w+\.\w+\b") ]]; then
          files=$(grep -sF "/${{ inputs.filename }}" "${{ env.database }}");
          echo -e "\n####################\nLiteral String Pattern Matching Active\n####################\n";
        else
          regex="\${{ inputs.filename }}$";
          files=$(grep -sE "${regex}" "${{ env.database }}");
          echo -e "\n####################\nExtended Regex Pattern Matching Active\n####################\n";
        fi;
        clang_file=$(grep -sF -m 1 '.clang-tidy' "${{ env.database }}");
        repaired=$(grep -sF -m 1 'check-file-repaired.txt' "${{ env.database }}");
        count2=0
        checked=false
        file_count=1
        include_count=1
        if [[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          if [[ -f "${clang_file}" ]] && ${{ inputs.repair }}; then
            echo -e '\n####################\n\t.clang-tidy found continuing...\n####################\n';
          elif [[ ! -f "${clang_file}" ]] && ${{ inputs.repair }}; then
            echo -e '\n####################\n\t.clang-tidy not found exiting...\n####################\n';
            exit 1
          fi;
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n";
            awk 'NR % 10 == 1 {print "---- Lines " NR " to " NR+9 " ----"} {print}' "${files}";
            echo -e '\t--------------------\n';
          fi;
          { time -p for f in ${files[@]}; do
            search_path="${f}";
            check_date=$(grep -sF "${search_path}" "${repaired}" | cut -d' ' -f 2-);
            count1=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count1})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count1})\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -n ${includes} ]]; then
                echo -e "\n# Found Include File(s):\n${includes}\n";
                include_paths='';
                separator=' -I';
                for i in ${includes[@]}; do
                  final="${i}";
                  count2=$((include_count++));
                  header=$(grep -F "/$(basename ${i})$" "${{ env.database }}");
                  for h in ${header[@]}; do
                    echo "$(dirname ${h/\\n /})" >> "$(dirname ${f})/${included1}";
                    include_paths+="${separator/\\n /}$(dirname ${h/\\n /})";
                  done;
                done;
                if [[ -f "$(dirname ${f})/${included1}" ]]; then
                  awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                fi;
                if [[ -n ${header} ]] && [[ -n ${include_paths} ]]; then
                  if ${{ inputs.content }}; then
                    included3=$(dirname ${f})/${included2}
                    echo -e "\n####################\n\tFILE PATH(S) (${count2})\n####################\n";
                    batcat --theme=ansi --paging=never --show-all --color=always --style=full "${included3}";
                  fi;
                  if ${{ inputs.repair }}; then
                    if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                      echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                      echo -e "\n####################\nRepaired on ${check_date}\nSkipping $(basename ${f})\n####################\n";
                    elif ${{ inputs.stored }} && ${{ env.update }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                      else
                        echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      echo "${f} $(date)" >> "${repaired}";
                      fixed=true
                    elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      fixed=true
                    fi;
                  else
                    echo -e "\n\n####################\nCPPCHECK INCLUDE FILE(S) ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --includes-file="${included3}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null; 
                    if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                      echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                    else
                      echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                    fi;
                  fi;
                else 
                  echo -e "\n\n####################\nHEADER FILE(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              else
                echo -e "\n\n####################\nINCLUDE FILE(S) FOR $(basename ${f}) NOT PRESENT\n####################\n\n";
              fi;
            else
              if ${{ inputs.repair }}; then
                if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                  echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                  echo -e "\n####################\nRepaired on ${check_date}\nSkipping $(basename ${f})\n####################\n";
                elif ${{ inputs.stored }} && ${{ env.update }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f -7)" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                  else
                    echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  echo "${f} $(date)" >> "${repaired}";
                  fixed=true
                elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f -7)" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  fixed=true
                fi;
              else
                echo -e "\n\n####################\nCPPCHECK FILE ANALYZER (${count1})\n####################\n\n";
                cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                fi;
              fi;
            fi;
            if ${{ inputs.recheck }} && ${{ inputs.repair }}; then
              echo -e "\n\n####################\nCPPCHECK RE-ANALYZING FILE(S) (${count1})\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nRECHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nRECHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if ${{ inputs.include }} && [[ -f "$(dirname ${f})/${included2}" ]]; then
              echo -e "# Included Path(s): ${include_paths/\\n /}";
              echo -e "\nInclude_File: $(rm -vf $(dirname ${f})/${included1})\n" 2>/dev/null;
              echo -e "\nInclude_Path: $(rm -vf $(dirname ${f})/${included2})\n" 2>/dev/null;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count1}\n";
          if ${{ inputs.include }}; then
            echo -e "Total number of included file(s) checked is: ${count2}\n";
          fi;
          echo -e "Scanning Completed!\nCheck-file Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
          if [[ "${fixed}" ]]; then
            echo "file_fixed=1" >> "${GITHUB_ENV}";
          fi;
        elif [[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING C/C++ FILE TYPES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Shell Files
      if: inputs.filename != '' && inputs.database != 'false' && env.file_found == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        fixed=false
        shellcheck_count=1
        repaired=$(grep -sF -m 1 'check-file-repaired.txt' "${{ env.database }}");
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        if [[ -n $(echo "${{ inputs.filename }}" | sed 's/[\/\$]//g' | grep -Po "\b\w+\.\w+\b") ]]; then
          files=$(grep -sF "/${{ inputs.filename }}" "${{ env.database }}");
          echo -e "\n####################\nLiteral String Pattern Matching Active\n####################\n";
        else
          regex="\${{ inputs.filename }}$";
          files=$(grep -sE "${regex}" "${{ env.database }}");
          echo -e "\n####################\nExtended Regex Pattern Matching Active\n####################\n";
        fi;
        if [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n";
            awk 'NR % 10 == 1 {print "---- Lines " NR " to " NR+9 " ----"} {print}' "${files}";
            echo -e '\t--------------------\n';
          fi;
          { time -p for f in ${files[@]}; do
            search_path="${f}";
            check_date=$(grep -Fs "${search_path}" "${repaired}" | cut -d' ' -f 2-);
            count3=$((shellcheck_count++));
            echo -e "\n####################\n\tFILE PATH (${count3})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.repair }}; then
              if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                echo -e "\n####################\nRepaired on ${check_date}\nSkipping $(basename ${f})\n####################\n";
              elif ${{ inputs.stored }} && ${{ env.update }}; then
                echo -e "\n\n####################\nSHELLHARDEN ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                else
                  echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                echo "${f} $(date)" >> "${repaired}";
                fixed=true
              elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                echo -e "\n\n####################\nSHELLHARDEN ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nSHELLHARDEN NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nSHELLHARDEN FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                fixed=true
              fi;
            fi;
            if ${{ inputs.recheck }}; then
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
              fi;
            elif ! ${{ inputs.repair }}; then
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
              fi;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count3}\n";
          echo -e "Scanning Completed!\nShellTools Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
          if [[ "${fixed}" ]]; then
            echo "file_fixed=1" >> "${GITHUB_ENV}";
          fi;
        elif [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING SH FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Makefile Files
      if: inputs.filename != '' && inputs.database != 'false' && env.file_found == 0
      run: |
        export LC_ALL=C
        set -o pipefail
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        if [[ -n $(echo "${{ inputs.filename }}" | sed 's/[\/\$]//g' | grep -Po "\b\w+\.\w+\b") ]]; then
          files=$(grep -sF "/${{ inputs.filename }}" "${{ env.database }}");
          echo -e "\n####################\nLiteral String Pattern Matching Active\n####################\n";
        else
          regex="\${{ inputs.filename }}$";
          files=$(grep -sE "${regex}" "${{ env.database }}");
          echo -e "\n####################\nExtended Regex Pattern Matching Active\n####################\n";
        fi;
        makefile_count=1
        if [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
          { time -p for f in ${files[@]}; do
            count4=$((makefile_count++));
            echo -e "\n####################\n\tFILE PATH (${count4})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || >/dev/null;
            if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND ${f}\n####################\n";
            else
              echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count4}\n";
          echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
        elif [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING MK FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check All Files
      if: inputs.filename != '' && inputs.database != 'false' && env.file_found == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        if [[ -n $(echo "${{ inputs.filename }}" | sed 's/[\/\$]//g' | grep -Po "\b\w+\.\w+\b") ]]; then
          files=$(grep -sF "/${{ inputs.filename }}" "${{ env.database }}");
          echo -e "\n####################\nLiteral String Pattern Matching Active\n####################\n";
        else
          regex="\${{ inputs.filename }}$";
          files=$(grep -sE "${regex}" "${{ env.database }}");
          echo -e "\n####################\nExtended Regex Pattern Matching Active\n####################\n";
        fi;
        file_count=1
        if [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          { time -p for f in ${files[@]}; do
            count5=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count5})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count5})\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count5}\n";
          echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
        else
          echo -e "\n####################\nFINISHED SEARCHING ALL FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check & Repair (Clang-tools)
      if: inputs.filename != '' && inputs.database != 'true'
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        clang_file=$(sudo find ${{ env.file_path }} -type f -name '.clang-tidy' -print -quit);
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        repaired=$(sudo find ${{ env.file_path }} -type f -name 'check-file-repaired.txt' -print -quit);
        count2=0
        checked=false
        file_count=1
        include_count=1
        if [[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          if [[ -f "${clang_file}" ]] && ${{ inputs.repair }}; then
            echo -e '\n####################\n\t.clang-tidy found continuing...\n####################\n';
          elif [[ ! -f "${clang_file}" ]] && ${{ inputs.repair }}; then
            echo -e '\n####################\n\t.clang-tidy not found exiting...\n####################\n';
            exit 1
          fi;
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n";
            awk 'NR % 10 == 1 {print "---- Lines " NR " to " NR+9 " ----"} {print}' "${files}";
            echo -e '\t--------------------\n';
          fi;
          { time -p for f in ${files[@]}; do
            search_path="${f}";
            check_date=$(grep -sF "${search_path}" "${repaired}" | cut -d' ' -f 2-);
            count1=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count1})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count1})\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "{f}";
            fi;
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -n ${includes} ]]; then
                echo -e "\n# Found Include File(s):\n${includes}\n";
                include_paths='';
                separator=' -I';
                for i in ${includes[@]}; do
                  final="${i}";
                  count2=$((include_count++));
                  header=$(sudo find ${{ env.file_path }} -type f \( -path "*/$(dirname ${i})/*" -o -path "${{ steps.set_dirname.outputs.dirname }}" \) -name "$(basename ${i})" -print -quit);
                  for h in ${header[@]}; do
                    echo "$(dirname ${h/\\n /})" >> "$(dirname ${f})/${included1}";
                    include_paths+="${separator/\\n /}$(dirname ${h/\\n /})";
                  done;
                done;
                if [[ -f "$(dirname ${f})/${included1}" ]]; then
                  awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                fi;
                if [[ -n ${header} ]] && [[ -n ${include_paths} ]]; then
                  if ${{ inputs.content }}; then
                    included3=$(dirname ${f})/${included2}
                    echo -e "\n####################\n\tFILE PATH(S) (${count2})\n####################\n";
                    batcat --theme=ansi --paging=never --show-all --color=always --style=full "${included3}";
                  fi;
                  if ${{ inputs.repair }}; then
                    if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                      echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                      echo -e "\n####################\nChecked on ${check_date}\nSkipping $(basename ${f})\n####################\n";
                    elif ${{ inputs.stored }} && ${{ env.update }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                      else
                        echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      echo "${f} $(date)" >> "${repaired}";
                      fixed=true
                    elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      fixed=true
                    fi;
                  else
                    echo -e "\n\n####################\nCPPCHECK INCLUDE FILE(S) ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --includes-file="${included3}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                    if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                      echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                    else
                      echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                    fi;
                  fi;
                else 
                  echo -e "\n\n####################\nHEADER FILE(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              else
                echo -e "\n\n####################\nINCLUDE FILE(S) FOR $(basename ${f}) NOT PRESENT\n####################\n\n";
              fi;
            else
              if ${{ inputs.repair }}; then
                if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                  echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                  echo -e "\n####################\nChecked on ${check_date}\nSkipping $(basename ${f})\n####################\n";
                elif ${{ inputs.stored }} && ${{ env.update }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f -7)" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                  else
                    echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  echo "${f} $(date)" >> "${repaired}";
                  fixed=true
                elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f -7)" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  fixed=true
                fi;
              else
                echo -e "\n\n####################\nCPPCHECK FILE ANALYZER (${count1})\n####################\n\n";
                cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                fi;
              fi;
            fi;
            if ${{ inputs.recheck }} && ${{ inputs.repair }}; then
              echo -e "\n\n####################\nCPPCHECK RE-ANALYZING FILE(S) (${count1})\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nRECHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nRECHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if ${{ inputs.include }} && [[ -f "$(dirname ${f})/${included2}" ]]; then
              echo -e "# Included Path(s): ${include_paths/\\n /}";
              echo -e "\nInclude_File: $(rm -vf $(dirname ${f})/${included1})\n" 2>/dev/null;
              echo -e "\nInclude_Path: $(rm -vf $(dirname ${f})/${included2})\n" 2>/dev/null;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count1}\n";
          if ${{ inputs.include }}; then
            echo -e "Total number of included file(s) checked is: ${count2}\n";
          fi;
          echo -e "Scanning Completed!\nCheck-file Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
          if [[ "${fixed}" ]]; then
            echo "file_fixed=1" >> "${GITHUB_ENV}";
          fi;
        elif [[ -n $(echo "${file_type}" | egrep "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING C/C++ FILE TYPES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Shell Files
      if: inputs.filename != '' && inputs.database != 'true' && env.file_found == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        fixed=false
        shellcheck_count=1
        repaired=$(sudo find ${{ env.file_path }} -type f -name 'check-file-repaired.txt' -print -quit);
        files=$(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        if [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n";
            awk 'NR % 10 == 1 {print "---- Lines " NR " to " NR+9 " ----"} {print}' "${files}";
            echo -e '\t--------------------\n';
          fi;
          { time -p for f in ${files[@]}; do
            search_path="${f}";
            check_date=$(grep -sF "${search_path}" "${repaired}" | cut -d' ' -f 2-);
            count3=$((shellcheck_count++));
            echo -e "\n####################\n\tFILE PATH (${count3})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.repair }}; then
              if ${{ inputs.stored }} && ${{ env.update }} && [[ $(grep -sF "${search_path}" "${repaired}") ]]; then
                echo -e "\n####################\nSTORED NOTHING TO REPAIR\n####################\n";
                echo -e "\n####################\nChecked on ${check_date}\nSkipping $(basename ${f})\n####################\n";
              elif ${{ inputs.stored }} && ${{ env.update }}; then
                echo -e "\n\n####################\nSHELLHARDEN ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nSTORING NO ERRORS FOUND\n####################\n\n${f}\n";
                else
                  echo -e "\n####################\nSTORING FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                echo "${f} $(date)" >> "${repaired}";
                fixed=true
              elif ! ${{ inputs.stored }} || ! ${{ env.update }}; then
                echo -e "\n\n####################\nSHELLHARDEN ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nSHELLHARDEN NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nSHELLHARDEN FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                fixed=true
              fi;
            fi;
            if ${{ inputs.recheck }}; then
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
              fi;
            elif ! ${{ inputs.repair }}; then
              echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" || >/dev/null;
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
              fi;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count3}\n";
          echo -e "Scanning Completed!\nShellTools Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
          if [[ "${fixed}" ]]; then
            echo "file_fixed=1" >> "${GITHUB_ENV}";
          fi;
        elif [[ -n $(echo "${file_type}" | egrep -i "^sh$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING SH FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Makefile Files
      if: inputs.filename != '' && inputs.database != 'true' && env.file_found == 0
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        makefile_count=1
        if [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          { time -p for f in ${files[@]}; do
            count4=$((makefile_count++));
            echo -e "\n####################\n\tFILE PATH (${count4})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || >/dev/null;
            if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND ${f}\n####################\n";
            else
              echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count4}\n";
          echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
        elif [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING MK FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check All Files
      if: inputs.filename != '' && inputs.database != 'true' && env.file_found == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_name="${{ inputs.filename }}";
        file_type="${file_name##*.}";
        file_count=1
        if [[ -n ${files} ]]; then
          echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
          { time -p for f in ${files[@]}; do
            count5=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count5})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count5})\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
          done; echo '| Runtime |'; } 2>&1
          echo -e "\nTotal number of $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') file(s) checked is: ${count5}\n";
          echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
          echo "file_found=1" >> "${GITHUB_ENV}";
        else
          echo -e "\n####################\nFINISHED SEARCHING ALL FILES\nNO $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g') FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Word text Match
      if: inputs.pattern != '' && inputs.database != 'false'
      run: |
        export LC_ALL=C
        set +e
        file_count=1
        echo -e "\n####################\n\033[1mWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\033[0m\n####################\n";
        echo -e "\n####################\n\033[1mPattern Matching: ${{ inputs.pattern }}\033[0m\n####################\n";
        if [[ "${{ inputs.filetype }}" != 'none' ]]; then
          for type in ${types[@]}; do
            echo '| Runtime |';
            matches=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*.${type}" -print | xargs -r -P "$(nproc --all)" sudo rg -j "$(nproc --all)" --color always -sHFn "${{ inputs.pattern }}" 2>/dev/null);
            matches=${matches};
            if [[ -n ${matches} ]]; then
              counter=$( echo "${matches}" | rg -c "${{ inputs.pattern }}" );
              echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S)\n####################\n";
              echo -e "\n${matches}\n";
              if ${{ inputs.content }}; then
                echo '| Runtime |';
                content=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${type}" -print | xargs -r -P "$(nproc --all)" sudo rg -j "$(nproc --all)" -l --quiet "${{ inputs.pattern }}" 2>/dev/null);
                content=${content};
                for c in ${content[@]}; do
                  count=$((file_count++));
                  echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                  echo -e "\n$(dirname ${c})\n":
                  echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                  batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                  echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              echo -e "\n####################\nPATTERN MATCH FINISHED SEARCHING\nNO $(echo ${{ inputs.pattern }} | sed 's/[\/\$]//g') FOUND\n####################\n";
            fi;
          done;
          echo -e "\nScanning Completed!\nPattern Locator\nExiting...\n";
        else
          echo '| Runtime |';
          matches=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -print | xargs -r -P "$(nproc --all)" sudo rg -j "$(nproc --all)" --color always -sHFn "${{ inputs.pattern }}" 2>/dev/null);
          matches=${matches};
          if [[ -n ${matches} ]]; then
            counter=$( echo "${matches}" | rg -c "${{ inputs.pattern }}" );
            echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN FILE(S)\n####################\n";
            echo -e "\n${matches}\n";
            if ${{ inputs.content }}; then
              echo '| Runtime |';
              content=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -print | xargs -r -P "$(nproc --all)" sudo rg -j "$(nproc --all)" -l --quiet "${{ inputs.pattern }}" 2>/dev/null);
              content=${content};
              for c in ${content[@]}; do
                count=$((file_count++));
                echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                echo -e "\n$(dirname ${c})\n":
                echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                echo -e "\n####################\nFILE COMPLETED\n####################\n";
              done;
            fi;
          else
            echo -e "\n####################\nPATTERN MATCH FINISHED SEARCHING\nNO $(echo ${{ inputs.pattern }} | sed 's/[\/\$]//g') FOUND\n####################\n";
          fi;
          echo -e "\nScanning Completed!\nPatterns Locator\nExiting...\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Word Pattern Match
      if: inputs.pattern != '' && inputs.database != 'true'
      run: |
        set +e
        file_count=1
        echo -e "\033[1m\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n\033[0m";
        echo -e "\033[1m\n####################\nPattern Matching: ${{ inputs.pattern }}\n####################\n\033[0m";
        if [[ "${{ inputs.filetype }}" != 'none' ]]; then
          for type in ${{ inputs.filetype }}; do
            echo '| Runtime |';
            matches=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*.${type}" -exec sudo grep --color=always -sHanF "${{ inputs.pattern }}" "{}" \; );
            matches=${matches};
            if [[ -n ${matches} ]]; then
              counter=$( echo "${matches}" | grep -c "${{ inputs.pattern }}" );
              echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S)\n####################\n";
              echo -e "\n${matches}\n";
              if ${{ inputs.content }}; then
                echo '| Runtime |';
                content=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${type}" -exec sudo grep -q "${{ inputs.pattern }}" "{}" \; );
                content=${content};
                for c in ${content[@]}; do
                  count=$((file_count++));
                  echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                  echo -e "\n$(dirname ${c})\n":
                  echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                  batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                  echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO $(echo ${{ inputs.pattern }} | sed 's/[\/\$]//g') FOUND\n####################\n";
            fi;
          done;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        else
          echo '| Runtime |';
          matches=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -exec sudo grep --color=always -sHanF "${{ inputs.pattern }}" "{}" \; );
          matches=${matches};
          if [[ -n ${matches} ]]; then
            counter=$( echo "${matches}" | grep -c "${{ inputs.pattern }}" );
            echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN FILE(S)\n####################\n";
            echo -e "\n${matches}\n";
            if ${{ inputs.content }}; then
              echo '| Runtime |';
              content=$(time -p sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -exec sudo grep -q "${{ inputs.pattern }}" "{}" \; );
              content=${content};
              for c in ${content[@]}; do
                count=$((file_count++));
                echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                echo -e "\n$(dirname ${c})\n":
                echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                echo -e "\n####################\nFILE COMPLETED\n####################\n";
              done;
            fi;
          else
            echo -e "\n####################\nPATTERN MATCH FINISHED SEARCHING\nNO $(echo ${{ inputs.pattern }} | sed 's/[\/\$]//g') FOUND\n####################\n";
          fi;
          echo -e "\nScanning Completed!\nPatterns Locator\nExiting...\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Directory Contains
      if: inputs.filename != '' && inputs.content != 'false'
      run: |
        echo ''
        check_file=$(dirname $(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}"));
        file_count=$(sudo find ${{ env.file_path }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) | wc -l);
        if [[ ${{ env.file_found }} != 0  ]]; then
          echo -e "\n####################\nNOTE: Contents found in directory for $(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')\n####################\n";
          ls -Shap "${check_file}";
          echo -e "\n[CLONED REPOSITORY] Total Files: ${file_count}\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Build Project
      if: inputs.project != 'false'
      run: |
        export LLVM_ENABLE_THREADS=ON
        export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        export LC_ALL=C
        set +e

        echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
        echo -e "\n####################\nProject Build: ${{ github.repository }}\n####################\n";
       
        clang_version=$(clang-tidy --version);
        verify_config=$(clang-tidy --verify-config 2>/dev/null);
        cmake_version=$(cmake --version);
        clang_config=$(clang-tidy --dump-config 2>/dev/null);
        clang_checks=$(clang-tidy --list-checks 2>/dev/null);
        llvm_version=$(llvm-config --version);
        check_build=false
        file_type='c';
        compiler=$(dpkg -l | grep -i 'compiler');
        src_tree=$(sudo find ${{ env.file_path }} -type d -name '.git' -print);
        update=true

        echo -e "\n####################\n${clang_version}\n####################\n";
        echo -e "\n####################\n${cmake_version}\n####################\n";
        echo -e "\n####################\nllvm version ${llvm_version}\n####################\n";
        echo -e "\n####################\nclang-tidy check: ${verify_config}\n####################\n";
        echo -e "\n####################\n.Clang-Tidy Config\n${clang_config}\n####################\n";
        echo -e "\n####################\nClang-Tidy List\n${clang_checks}\n####################\n";
        
        if ! ${{ inputs.update }}; then
          echo 'update=false' >> "${GITHUB_ENV}";
          update=false
        fi;

        if [[ "${{ inputs.filetype }}" != 'none' ]]; then
          file_type="${{ inputs.filetype }}"
        fi;
        
        if [[ -d "${src_tree}" ]]; then
          echo -e "\n####################\nChecking Repository ${src_tree%/*}\n####################\n";
          echo -e "\n####################\nChecking for ${file_type} file(s)\n####################\n";

          cd "${src_tree%/*}";
          cmake_list='CMakeLists.txt';
          clang_file='clang_tidy_params.txt';
          clang_tidy='.clang-tidy';
          compile_json=$(sudo find . -type f -name 'compile_commands.json' -print -quit);
          clang_run=$(sudo find / -type f -name 'run-clang-tidy.py' -print -quit 2>/dev/null);
          file_list=$(sudo find . -type f -name "*.${file_type}" -print);
          dirs_list=$(sudo find . -type d -name 'include' -print);
          IFS=$'\n';

          if [[ -s "${clang_tidy}" ]]; then
            echo -e '\n####################\n\t.clang-tidy found continuing...\n####################\n';
          fi;

          if [[ -s "${cmake_list}" ]]; then
            echo -e '\n####################\n\tCMakeLists.txt found continuing...\n####################\n';
          fi;

          if ${{ inputs.build }}; then
            mkdir -p build
            if [[ -d 'build' ]]; then
              echo -e '\n####################\n\tbuild directory created continuing...\n####################\n';
              cmake -S . -DCMAKE_EXPORT_COMPILE_COMMANDS=ON build || echo "Error: ( $? ) cmake missing or malformed CMakeList.txt (?)";
              cmake --build build || echo "Error: ( $? ) cmake build source corrupted or malformed CMakeList.txt (?)";
              check_build=true
            fi;      
          else
            mkdir -p build
            if [[ -d 'build' ]]; then
              echo -e '\n####################\n\tbuild directory created continuing...\n####################\n';
              cmake -S . -DCMAKE_EXPORT_COMPILE_COMMANDS=ON build || echo "Error: ( $? ) cmake missing or malformed CMakeList.txt (?)";
              if ${{ inputs.report }}; then
                echo 'build_files=1' >> "${GITHUB_ENV}";
                cp -Rf ./build 
              fi;
            fi;
          fi;

          if [[ -s "${clang_file}" ]] && ${{ inputs.analysis == 1 }} && ! ${{ inputs.build }}; then
            echo ' ' >> "${clang_file}";
            if [[ -n "${dirs_list}" ]]; then
              echo -e '\n####################\n\tinclude directories found continuing...\n####################\n';
              for dir in ${dirs_list[@]}; do
                if [[ -d "$(echo ${dir} | grep -sqwF include)" ]]; then
                  echo "${dir}" | sed 's/^\.\///' >> "${clang_file}";
                fi;
              done;
            fi;
            if [[ -n "${file_list}" ]]; then
              echo -e "\n####################\n\t${file_type} file(s) found continuing...\n####################\n";
              echo "${file_list}" >> "${clang_file}";
            fi;
            echo -e "\n####################\n\t${clang_file} found continuing...\n####################\n";
            echo -e '\n####################\nCLANG-TIDY ANALYZING CLANG PARAMS FILE\n####################\n';
            { time -p \
              clang-tidy @clang_tidy_params.txt --fix-errors 2>/dev/null;
            } 2>&1 | tee -a "${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log" || echo "Error: ( $? ) checking project files";
            echo -e '\n|RUNTIME|';
            check_build=true
          elif [[ ! -f "${clang_file}" ]] && ${{ inputs.analysis == 1 }} && ! ${{ inputs.build }}; then
            echo -e "\n####################\n\tclang_tidy_params.txt missing in repo Exiting...\n####################\n";
          fi;

          if [[ -f "${clang_run}" ]] && ${{ inputs.analysis == 2 }} && ! ${{ inputs.build }}; then
            echo -e "\n####################\n\trun-clang-tidy.py found continuing...\n####################\n";
            echo -e '\n####################\nRUN-CLANG-TIDY ANALYZING COMPILE COMMAND FILE\n####################\n';
            { time -p \
              python3 "${clang_run}" -fix -checks=-*,readability-* -j "$(nproc--all)" -p=build/ && \
              python3 "${clang_run}" -fix -checks=-*,llvm-header-guard extra/clang-tidy \
              -header-filter=extra/clang-tidy;
            } 2>&1 | tee -a "${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log" || echo "Error: ( $? ) checking project files";
            echo -e '\n|RUNTIME|';
            check_build=true
          elif [[ -n "$(python3 ./scripts/tools/run-clang-tidy.py)" ]] && ${{ inputs.analysis == 2 }} && ! ${{ inputs.build }}; then
            echo -e "\n####################\n\trun-clang-tidy.py found continuing...\n####################\n";
            echo -e '\n####################\nRUN-CLANG-TIDY ANALYZING COMPILE COMMAND FILE\n####################\n';
            { time -p \
              python3 ./scripts/tools/run-clang-tidy.py -fix -checks=-*,readability-* -j "$(nproc--all)" -p=build/ && \
              python3 ./scripts/tools/run-clang-tidy.py -fix -checks=-*,llvm-header-guard extra/clang-tidy \
              -header-filter=extra/clang-tidy;
            } 2>&1 | tee -a "${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log" || echo "Error: ( $? ) checking project files";
            echo -e '\n|RUNTIME|';
            check_build=true
          elif [[ ! -f "${clang_run}" ]] && ${{ inputs.analysis == 2 }} && ! ${{ inputs.build }}; then
            echo -e "\n####################\n\tcompile_commands.json missing in repo Exiting...\n####################\n";
          fi;

          if [[ -s "${compile_json}" ]] && ${{ inputs.analysis == 3 }} && ! ${{ inputs.build }}; then
            echo -e '\n####################\n\tcompile_commands.json created continuing...\n####################\n';
            echo -e '\n####################\nCLANG-TIDY ANALYZING COMPILE COMMAND FILE\n####################\n';
            cp -v "${compile_json}" './build/' 2>/dev/null;
            { time -p \
              clang-tidy --config-file="${clang_tidy}" --fix-errors -p build/;
            } 2>&1 | tee -a "${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log" || echo "Error: ( $? ) checking project files";
            check_build=true
          elif [[ ! -f "${compile_json}" ]] && ${{ inputs.analysis == 3 }} && ! ${{ inputs.build }}; then
            echo -e "\n####################\n\trun-clang-tidy.py missing in repo Exiting...\n####################\n";
          fi;

          if [[ ! -s "${clang_file}" ]] && [[ ! -s "${compile_json}" ]]; then
            echo -e "\n####################\n\t${clang_file} not found\n\tcompile_commands.json not created or empty\nExiting...\n####################\n";
            exit 1
          fi;

          if [[ ${update} ]] && ${{ inputs.analysis == 1 }}; then
            echo -e "\nCLANG-PARAMS: $(rm -vf ${clang_file} 2>/dev/null)\n";
          fi;

          echo -e "\n####################\nCompilers List:\n${compiler}\n####################\n";

          if [[ ${check_build} ]]; then
            echo -e "\n####################\n\tProject Checked Exiting...\n####################\n";
            echo 'file_fixed=1' >> "${GITHUB_ENV}";
          else
            echo -e "\n####################\n\tProject Not Checked Exiting...\n####################\n";
          fi;
        else
          echo 'Error .git directory not found?';
        fi;
      shell: bash
      continue-on-error: true

      
    - name: Repository Update
      if: env.update == 'true' && env.file_fixed == 1
      run: |
        echo '';
        repair_date="$(date +%Y%m%d)";
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name ".git" -print | grep -v llvm-project);
        if [[ -d ${repository} ]]; then
          cd "${repository%/*}";
          if ${{ inputs.project }}; then
            git config --global --add safe.directory .
          fi;
          git config --global user.name "${{ github.actor }}";
          git config --global user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com";
          git config --global credential.helper store
          git config --global http.lowSpeedLimit 0
          git config --global http.lowSpeedTime 999999
          git add .
          git commit -m "check-file-action repaired errors in ${{ inputs.filename }} file(s)";
          git push origin "${{ github.ref }}";
          if [[ ${PIPESTATUS[0]} == 0 ]] || [[ ${PIPESTATUS[1]} == 0 ]]; then
            echo -e "\n####################\nCHECK FILE UPDATED REPOSITORY\n####################\n";
            echo -e "\n####################\nUPDATED FILE(S) LIST:\n####################\n";
            git diff --name-only @{push}@{1} @{push} |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log";
            echo -e "\n\t########## ${repair_date} ##########\n";
          else
            echo -e "\n####################\nCHECK FILE COULD NOT UPDATED REPO FILE(S)\n####################\n";
            echo 'Retrying again after git fetches branch';
            git fetch origin "${{ github.ref }}";
            git add .
            git commit -m "check-file-action repaired errors in ${{ inputs.filename }} file(s)";
            git push origin "${{ github.ref }}";
            if [[ ${PIPESTATUS[0]} == 0 ]] || [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECK FILE UPDATED REPOSITORY\n####################\n";
              echo -e "\n####################\nUPDATED FILE(S) LIST:\n####################\n";
              git diff --name-only @{push}@{1} @{push} |& tee -a "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log";
              echo -e "\n\t########## ${repair_date} ##########\n";
              if ${{ inputs.project }}; then
                git status 2>/dev/null;
              fi;
            else
              echo 'Was git push event successful status ? unknown';
            fi;
          fi;
        else
          echo -e "\n####################\nCHECK FILE CANT FIND (.git) DIR FOR UPDATING\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Uploading ${{ inputs.filename }} Error Report
      if: inputs.report != 'false' && inputs.filename != '' && env.file_error == 1
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./${{ inputs.filename }}_error.log
        name: Check File Action Errors Report For ${{ inputs.filename }} File(s).
        tag_name: ${{ github.run_id }}
      continue-on-error: true


    - name: Uploading ${{ github.repository }} Project Report 1
      if: inputs.report != 'false' && inputs.project != 'false' && env.file_error == 1
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log
        name: Check File Action Build Report For ${{ github.repository }} Repository.
        tag_name: ${{ github.run_id }}
      continue-on-error: true


    - name: Uploading ${{ github.repository }} Project Report 2
      if: inputs.report != 'false' && inputs.project != 'false' && env.build_files == 1
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./build/*
          ./$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log
        name: Check File Action Build Report For ${{ github.repository }} Repository.
        tag_name: ${{ github.run_id }}
      continue-on-error: true


    - name: Delete Files
      if: inputs.filename != '' || inputs.pattern != '' || inputs.project != 'false'
      run: |
        date
        if [[ -f "${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log" ]]; then
          echo -e "\nPROJECT: $(rm -vf ${GITHUB_WORKSPACE}/$(echo ${{ github.repository }} | cut -d'/' -f 2)_project.log)\n";
        fi;
        if [[ -f "${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log" ]]; then
          echo -e "\nLOGFILE: $(rm -vf ${GITHUB_WORKSPACE}/$(echo ${{ inputs.filename }} | sed 's/[\/\$]//g')_error.log)\n";
        fi;
        if [[ -f "${GITHUB_WORKSPACE}/database" ]]; then
          echo -e "\nDATABASE: $(rm -vf ${GITHUB_WORKSPACE}/database)\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Exiting 
      run: |
        echo '';
        export TERM=xterm-256color
        if [[ -n ${TERM} ]]; then
          center_text() {
            local text="$1";
            local term_cols="$(tput cols)";
            local text_length="${#text}";
            if [[ -n $(node ./scripts/mobile.js 2>/dev/null) ]] || [[ -n $(node ./scripts/view.js 2>/dev/null) ]]; then
              local padding="$(( (term_cols - text_length) / 2 ))";
              local text="$(echo $1 | tr -d '\n')";
              print '';
              printf "%*s%s\n" "${padding}" "" "${text}"
              print '';
            else
              echo -e "${text}"
            fi;
          }
        fi;
        texta="######################";
        textb="# CHECK FILE EXITING #";
        textc="######################";
        center_text "\n${texta}";
        center_text "${textb}";
        center_text "${textc}\n";
      shell: bash
      continue-on-error: true


    - name: Filename Check
      if: inputs.filename == '' && inputs.pattern == '' && inputs.project != 'true'
      run: |
        echo ''
        echo -e "\nNo input provided!\nVariables not set\n filename\n pattern\n\t Exiting\n";
      shell: bash
      continue-on-error: true

## Version 2.0.0 Professional (beta 3)
