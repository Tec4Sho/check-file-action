name: Check File Action
description: 'Check file - Add filename to check for errors or text Word to search for within workspace files'
inputs:
  filename:
    description: 'Check for filename or search for text word matches'
    type: string
    required: false
    default: ''
  filetype:
    description: 'Check only these file extension types when searching for text word matches'
    type: string
    required: false
    default: 'none'
  filetext:
    description: 'Search for text string matches in selected or all files'
    type: string
    required: false
    default: ''
  database:
    description: 'Use file database over find commands slower performance for searches'
    type: boolean 
    required: false
    default: 'false'
  dirname:
    description: 'Your project root folder if created'
    type: string
    required: false
    default: ''
  rootdir:
    description: 'Search will start from root (/) if true'
    type: boolean
    required: false
    default: 'false'
  content:
    description: 'Search will list dir contents of found filename if true'
    type: boolean
    required: false
    default: 'false'
  include:
    description: 'Check include files called by C/C++ filename searches if true'
    type: boolean
    required: false
    default: 'false'
  recheck:
    description: 'Recheck files repaired by check-file'
    type: boolean
    required: false
    default: 'false'
  repair:
    description: 'Check file and fix if able when searching for errors'
    type: boolean
    required: false
    default: 'false'
  report:
    description: 'Errors found will be logged and sent to repository releases'
    type: boolean
    required: false
    default: 'false'
  update:
    description: 'Errors repaired with check-file will push changes to remote repository'
    type: boolean
    required: false
    default: 'false'
  stored:
    description: 'Check files with errors repaired are skipped if ran again'
    type: boolean
    required: false
    default: 'false'
  number:
    description: 'Number of files to check before stopping action'
    type: number
    required: false
    default: 0

runs:
  using: composite
  steps:
    - name: Set up Go 1.25.3
      if: inputs.filename != ''
      uses: actions/setup-go@v2 
      with: 
        go-version: 1.25.3


    - name: Installing Dependencies
      if: inputs.filetext != '' || inputs.filename != ''
      run: |
        set -o pipefail
        export GIT_DISCOVERY_ACROSS_FILESYSTEM=1
        export DEBIAN_FRONTEND=noninteractive
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file=$(sudo find ${GITHUB_WORKSPACE} -type f -name "checkmake.ini" -print -quit);
        path='/home/runner/checkmake.ini';
        echo 'deb [trusted=yes] https://apt.gabe565.com /' | sudo tee /etc/apt/sources.list.d/gabe565.list;
        sudo add-apt-repository universe >/dev/null;
        sudo add-apt-repository ppa:git-core/ppa >/dev/null;
        sudo apt-get update -yq >/dev/null 2>&1;

        if [[ ! $(which git) ]]; then
          sudo apt-get -yq install git >/dev/null && echo -e "\n####################\n\t.Git dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which rg) ]]; then
          sudo apt-get -yq install ripgrep >/dev/null && echo -e "\n####################\n\tRipgrep dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which ansi2txt) ]]; then
          sudo apt-get -yq install ansi2txt >/dev/null && echo -e "\n####################\n\tAnsi2txt dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which update-ca-certificates) ]]; then
          sudo apt-get -yq install ca-certificates >/dev/null && echo -e "\n####################\n\tCa-certificates dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which cppcheck) ]] && [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          sudo apt-get -yq install cppcheck >/dev/null && echo -e "\n####################\n\tCppcheck dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which clang-tidy) ]] && [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          sudo apt-get -yq install clang-tidy clang-format >/dev/null && echo -e "\n####################\n\Clang-tool dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which shellharden) ]] && [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          wget -qO shellharden.tar.gz https://github.com/anordal/shellharden/releases/latest/download/shellharden-x86_64-unknown-linux-gnu.tar.gz
          sudo tar xf shellharden.tar.gz -C /usr/local/bin shellharden && rm -vrf shellharden.tar.gz && echo -e "\n####################\n\tShellharden dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which shellcheck) ]] && [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          sudo apt-get -yq install shellcheck >/dev/null && echo -e "\n####################\n\tShellcheck dependencies Installed\n####################\n";
        fi;

        if [[ ! $(which checkmake) ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          go install "github.com/checkmake/checkmake/cmd/checkmake@latest" >/dev/null && echo -e "\n####################\n\tCheckmake dependencies Installed\n####################\n";     
          if [[ -n ${file} ]]; then
            echo -e "\n####################\n\tcheckmake.ini found copying...\n####################\n";
            sudo cp -vf "${file}" "${path}" 2>/dev/null;
          fi;
        elif [[ -n ${file} ]] && [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          sudo cp -vf "${file}" "${path}" 2>/dev/null;
        fi;

        if [[ $(which bat) ]] && [[ ! $(which batcat) ]]; then
          sudo ln -sf ~/usr/bin/bat ~/usr/bin/batcat >/dev/null 2>&1;
          echo "########## $(which batcat) ##########" || echo "No batcat found Exiting... $(exit 1)";
          sudo bash -c echo -e "\nalias batcat='bat'" >> ~/.bashrc 2>/dev/null;
          export BAT_THEME="ansi";
        elif [[ ! $(which batcat) ]]; then
          sudo apt-get -yq install bat >/dev/null && echo -e "\n####################\n\tBatcat dependencies Installed\n####################\n";
          echo "########## $(which batcat) ##########" || echo "No batcat found Exiting... $(exit 1)";
          export BAT_THEME="ansi";
        fi;

        sudo apt-get --fix-broken install -yq >/dev/null 2>&1;
      shell: bash
      continue-on-error: false


    - name: Set Directory Base
      if: inputs.filetext != '' || inputs.filename != ''
      id: set_dirname 
      env: 
        DEFAULT_PATH: "*" 
      run: |
        set -o pipefail
        if ${{ inputs.rootdir }}; then
          echo -e "\n####################\nDEFAULT DIRECTORY (SYSTEM ROOT)\n####################\n";
          echo -e "\n ~/\n";
          echo "FILE_PATH=/" >> "${GITHUB_ENV}";
          FILE_PATH=/
        else
          echo -e "\n####################\nDEFAULT DIRECTORY (GITHUB WORKSPACE)\n####################\n";
          echo -e "\n${GITHUB_WORKSPACE}\n";
          echo "FILE_PATH=${GITHUB_WORKSPACE}" >> "${GITHUB_ENV}";
          FILE_PATH=${GITHUB_WORKSPACE}
        fi;

        if ${{ inputs.database }}; then
          sudo find "${FILE_PATH}" -name "*" -print > "${GITHUB_WORKSPACE}/check_file_list.txt";
          if [[ -f "${GITHUB_WORKSPACE}/check_file_list.txt" ]]; then
            echo -e "\n####################\ncheck_file_list database found\n####################\n";
            echo "DATABASE=${GITHUB_WORKSPACE}/check_file_list.txt" >> "${GITHUB_ENV}";
          fi;
        fi;

        if [[ "${{ inputs.filename }}" != '' ]]; then
          echo -e "\n####################\nSearching directories for ${{ inputs.filename }} file(s)\n####################\n";
        fi;

        if [[ "${{ inputs.filetext }}" != '' ]] && [[ ${{ inputs.filetype }} != 'none' ]]; then
          echo -e "\n####################\nSearching ${{ inputs.filetype }} files for ${{ inputs.filetext }} match(s)\n####################\n";
        elif [[ "${{ inputs.filetext }}" != '' ]]; then
          echo -e "\n####################\nSearching all files for ${{ inputs.filetext }} match(s)\n####################\n";
        fi;
      
        if [[ "${{ inputs.dirname }}" == '' ]]; then
          if [ -z "${{ github.event.inputs.DEVICE_PATH }}" ]; then 
            echo "dirname=${{ env.DEFAULT_PATH }}" >> "$GITHUB_OUTPUT";
          else 
            echo "dirname=${{ github.event.inputs.DEVICE_PATH }}" >> "$GITHUB_OUTPUT";
          fi;
        else
          echo "dirname=${{ inputs.dirname }}" >> "$GITHUB_OUTPUT";
        fi;
        echo "FILE_FIXED=0" >> "${GITHUB_ENV}";
        echo "FILE_FOUND=0" >> "${GITHUB_ENV}";
        echo "FILE_ERROR=0" >> "${GITHUB_ENV}";
      shell: bash
      continue-on-error: false


    - name: Check & Repair (Clang-tools)
      if: inputs.filename != '' && inputs.database != 'false'
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo rg "/${{ inputs.filename }}$" "${{ env.DATABASE }}");
        file_path=$(sudo rg -F '.clang-tidy' "${{ env.DATABASE }}");
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        clang_file=${GITHUB_WORKSPACE}/.clang-tidy;
        repaired=$(sudo rg -F 'check-file-repaired.txt' "${{ env.DATABASE }}");
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name '.git' -print -quit);
        repair_file='check-file-repaired.txt';
        count2=0
        checked=false
        file_count=1
        include_count=1
        if [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          if [[ -f "${file_path}" ]] && ${{ inputs.repair }}; then
            echo -e "\n####################\n\t.clang-tidy found copying...\n####################\n";
            sudo cp -vf "${file_path}" "${clang_file}";
          fi;
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n${files}\n";
          fi;
          if [[ -d ${repository} ]] && ${{ inputs.repair }}; then
            repository="${repository%/*}/${repair_file}";
            if [[ -f ${repository} ]]; then
              echo -e "\n####################\nRepaired files list found!!!\n####################\n";
              date >> "${repository}";
            else
              date > "${repository}";
              sudo find "${{ env.FILE_PATH }}" -name "*" -print > "${GITHUB_WORKSPACE}/check_file_list.txt";
            fi;
          fi;
          (time -p for f in ${files[@]}; do
            SEARCH_PATH="${f}";
            export count1=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count1})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count1})\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -n ${includes} ]]; then
                echo -e "\n# Found Include File(s):\n${includes}\n";
                include_paths='';
                separator=' -I';
                for i in ${includes[@]}; do
                  final="${i}";
                  export count2=$((include_count++));
                  header=$(sudo rg -F "/$(basename ${i})$" "${{ env.DATABASE }}");
                  for h in ${header[@]}; do
                    echo "$(dirname ${h/\\n /})" >> "$(dirname ${f})/${included1}";
                    include_paths+="${separator/\\n /}$(dirname ${h/\\n /})";
                  done;
                done;
                if [[ -f "$(dirname ${f})/${included1}" ]]; then
                  awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                fi;
                if [[ -n ${header} ]] && [[ -n ${include_paths} ]]; then
                  if ${{ inputs.content }}; then
                    included3=$(dirname ${f})/${included2}
                    echo -e "\n####################\n\tFILE PATH(S) (${count2})\n####################\n";
                    batcat --theme=ansi --paging=never --show-all --color=always --style=full "${included3}";
                  fi;
                  if ${{ inputs.repair }}; then
                    if ${{ inputs.stored }} && [[ $(grep -Fs "${SEARCH_PATH}" "${repaired}") ]]; then
                      echo -e "\n####################\nCHECK-FILE NOTHING TO REPAIR\n####################\n";
                      echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
                    elif ${{ inputs.stored }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      echo "${f}" >> "${repaired}";
                      fixed=true
                    elif ! ${{ inputs.stored }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      fixed=true
                    fi;
                  else
                    echo -e "\n\n####################\nCPPCHECK INCLUDE FILE(S) ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 --includes-file="${included3}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                    if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                      echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                    else
                      echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                    fi;
                  fi;
                else 
                  echo -e "\n\n####################\nHEADER FILE(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              else
                echo -e "\n\n####################\nINCLUDE FILE(S) FOR $(basename ${f}) NOT PRESENT\n####################\n\n";
              fi;
            else
              if ${{ inputs.repair }}; then
                if ${{ inputs.stored }} && [[ $(grep -Fs "${SEARCH_PATH}" "${repaired}") ]]; then
                  echo -e "\n####################\nCHECK-FILE NOTHING TO REPAIR\n####################\n";
                  echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
                elif ${{ inputs.stored }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f 1-6)" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  echo "${f}" >> "${repaired}";
                  fixed=true
                elif ! ${{ inputs.stored }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f 1-6)" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  fixed=true
                fi;
              else
                echo -e "\n\n####################\nCPPCHECK FILE ANALYZER (${count1})\n####################\n\n";
                cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                fi;
              fi;
            fi;
            if ${{ inputs.recheck }} && ${{ inputs.repair }}; then
              echo -e "\n\n####################\nCPPCHECK RE-ANALYZING FILE(S) (${count1})\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nRECHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nRECHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if ${{ inputs.include }} && [[ -f "$(dirname ${f})/${included2}" ]]; then
              echo -e "# Included Path(s): ${include_paths/\\n /}";
              echo -e "\nInclude_File: $(rm -vf $(dirname ${f})/${included1})\n" 2>/dev/null;
              echo -e "\nInclude_Path: $(rm -vf $(dirname ${f})/${included2})\n" 2>/dev/null;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          if [[ "${fixed}" ]]; then
            echo "FILE_FIXED=1" >> "${GITHUB_ENV}";
          fi;
          echo -e "\n\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count1}\n";
          if ${{ inputs.include }}; then
            echo -e "Total number of included file(s) checked is: ${count2}\n";
          fi;
          echo -e "Scanning Completed!\nCheck-file Exiting!\n .....\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
        elif [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING C/C++ FILE TYPES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Shell Files
      if: inputs.filename != '' && inputs.database != 'false' && env.FILE_FOUND == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        fixed=false
        shellcheck_count=1
        repair_file='check-file-repaired.txt';
        repaired=$(sudo rg -F 'check-file-repaired.txt' "${{ env.DATABASE }}");
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name '.git' -print -quit);
        files=$(sudo rg "/${{ inputs.filename }}$" "${{ env.DATABASE }}");
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        if [[ -n $(echo "${file_type}" | grep -i "^sh$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n${files}\n";
          fi;
          if [[ -d ${repository} ]] && ${{ inputs.repair }}; then
            repository="${repository%/*}/${repair_file}";
            if [[ -f ${repository} ]]; then
              echo -e "\n####################\nRepaired files list found!!!\n####################\n";
              date >> "${repository}";
            else
              date > "${repository}";
              sudo find "${{ env.FILE_PATH }}" -name "*" -print > "${GITHUB_WORKSPACE}/check_file_list.txt";
            fi;
          fi;
          (time -p for f in ${files[@]}; do
            SEARCH_PATH="${f}";
            export count3=$((shellcheck_count++));
            echo -e "\n####################\n\tFILE PATH (${count3})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.repair }}; then
              SHELL=SHELLHARDEN
              if ${{ inputs.stored }} && grep -qs "${SEARCH_PATH}" "${repaired}"; then
                echo -e "\n####################\n${SHELL} NOTHING TO REPAIR\n####################\n";
                echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
              elif ${{ inputs.stored }}; then
                echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\n${SHELL} FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                echo "${f}" >> "${repaired}";
                fixed=true
              elif ! ${{ inputs.stored }}; then
                echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\n${SHELL} FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                fixed=true
              fi;
            fi;
            if ${{ inputs.recheck }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            elif ! ${{ inputs.repair }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          if [[ "${fixed}" ]]; then
            echo "FILE_FIXED=1" >> "${GITHUB_ENV}";
          fi;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count3\n";
          echo -e "Scanning Completed!\nShellTools Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING SH FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Makefile Files
      if: inputs.filename != '' && inputs.database != 'false' && env.FILE_FOUND == 0
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo rg "/${{ inputs.filename }}$" "${{ env.DATABASE }}");
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        makefile_count=1
        if [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          (time -p for f in ${files[@]}; do
            export count4=$((makefile_count++));
            echo -e "\n####################\n\tFILE PATH (${count4})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || >/dev/null;
            if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND ${f}\n####################\n";
            else
              echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count4\n";
          echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING MK FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check All Files
      if: inputs.filename != '' && inputs.database != 'false' && env.FILE_FOUND == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo rg "/${{ inputs.filename }}$" "${{ env.DATABASE }}");
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file_count=1
        if [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          (time -p for f in ${files[@]}; do
            export count5=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count5})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count5})\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count5}\n";
          echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
        else
          echo -e "\n####################\nFINISHED SEARCHING ALL FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check & Repair (Clang-tools)
      if: inputs.filename != '' && inputs.database != 'true'
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_path=$(sudo find ${{ env.FILE_PATH }} -type f -name '.clang-tidy' -print -quit);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        clang_file=${GITHUB_WORKSPACE}/.clang-tidy;
        repaired=$(sudo find ${{ env.FILE_PATH }} -type f -name 'check-file-repaired.txt' -print -quit);
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name ".git" -print -quit);
        repair_file='check-file-repaired.txt';
        count2=0
        checked=false
        file_count=1
        include_count=1
        if [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          if [[ -f "${file_path}" ]] && ${{ inputs.repair }}; then
            echo -e "\n####################\n\t.clang-tidy found copying...\n####################\n";
            sudo cp -vf "${file_path}" "${clang_file}";
          fi;
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n${files}\n";
          fi;
          if [[ -d ${repository} ]] && ${{ inputs.repair }}; then
            repository="${repository%/*}/${repair_file}";
            if [[ -f ${repository} ]]; then
              echo -e "\n####################\nRepaired files list found!!!\n####################\n";
              date >> "${repository}";
            else
              date > "${repository}";
            fi;
          fi;
          (time -p for f in ${files[@]}; do
            SEARCH_PATH="${f}";
            export count1=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count1})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count1})\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "{f}";
            fi;
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -n ${includes} ]]; then
                echo -e "\n# Found Include File(s):\n${includes}\n";
                include_paths='';
                separator=' -I';
                for i in ${includes[@]}; do
                  final="${i}";
                  export count2=$((include_count++));
                  header=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/$(dirname ${i})/*" -o -path "${{ steps.set_dirname.outputs.dirname }}" \) -name "$(basename ${i})" -print -quit);
                  for h in ${header[@]}; do
                    echo "$(dirname ${h/\\n /})" >> "$(dirname ${f})/${included1}";
                    include_paths+="${separator/\\n /}$(dirname ${h/\\n /})";
                  done;
                done;
                if [[ -f "$(dirname ${f})/${included1}" ]]; then
                  awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                fi;
                if [[ -n ${header} ]] && [[ -n ${include_paths} ]]; then
                  if ${{ inputs.content }}; then
                    included3=$(dirname ${f})/${included2}
                    echo -e "\n####################\n\tFILE PATH(S) (${count2})\n####################\n";
                    batcat --theme=ansi --paging=never --show-all --color=always --style=full "${included3}";
                  fi;
                  if ${{ inputs.repair }}; then
                    if ${{ inputs.stored }} && [[ $(grep -s "${SEARCH_PATH}" "${repaired}") ]]; then
                      echo -e "\n####################\nCHECK-FILE NOTHING TO REPAIR\n####################\n";
                      echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
                    elif ${{ inputs.stored }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      echo "${f}" >> "${repaired}";
                      fixed=true
                    elif ! ${{ inputs.stored }}; then
                      echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                      clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- "${include_paths}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                      if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                        echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                      else
                        echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                      fi;
                      fixed=true
                    fi;
                  else
                    echo -e "\n\n####################\nCPPCHECK INCLUDE FILE(S) ANALYZER (${count2})\n####################\n\nFinal File: ${final}\n\n";
                    cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 --includes-file="${included3}" "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                    if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                      echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                    else
                      echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                    fi;
                  fi;
                else 
                  echo -e "\n\n####################\nHEADER FILE(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              else
                echo -e "\n\n####################\nINCLUDE FILE(S) FOR $(basename ${f}) NOT PRESENT\n####################\n\n";
              fi;
            else
              if ${{ inputs.repair }}; then
                if ${{ inputs.stored }} && [[ $(grep -s "${SEARCH_PATH}" "${repaired}") ]]; then
                  echo -e "\n####################\nCHECK-FILE NOTHING TO REPAIR\n####################\n";
                  echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
                elif ${{ inputs.stored }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f 1-6)" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  echo "${f}" >> "${repaired}";
                  fixed=true
                elif ! ${{ inputs.stored }}; then
                  echo -e "\n\n####################\nCLANG-TIDY FILES ANALYZER (${count1})\n####################\n\n";
                  clang-tidy "${f}" --config-file="${clang_file}" --fix-errors --fix-notes -- -I"$(dirname "${f}" | cut -d'/' -f 1-6)" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                  if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                    echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                  else
                    echo -e "\n####################\nCHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
                  fi;
                  fixed=true
                fi;
              else
                echo -e "\n\n####################\nCPPCHECK FILE ANALYZER (${count1})\n####################\n\n";
                cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\nCHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\nCHECK-FILE FOUND ERROR(S)\n####################\n";
                fi;
              fi;
            fi;
            if ${{ inputs.recheck }} && ${{ inputs.repair }}; then
              echo -e "\n\n####################\nCPPCHECK RE-ANALYZING FILE(S) (${count1})\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --error-exitcode=1 "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\nRECHECK-FILE NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\nRECHECK-FILE FOUND ERROR(S) TO REPAIR\n####################\n";
              fi;
            fi;
            if ${{ inputs.include }} && [[ -f "$(dirname ${f})/${included2}" ]]; then
              echo -e "# Included Path(s): ${include_paths/\\n /}";
              echo -e "\nInclude_File: $(rm -vf $(dirname ${f})/${included1})\n" 2>/dev/null;
              echo -e "\nInclude_Path: $(rm -vf $(dirname ${f})/${included2})\n" 2>/dev/null;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          if [[ "${fixed}" ]]; then
            echo "FILE_FIXED=1" >> "${GITHUB_ENV}";
          fi;
          echo -e "\n\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count1}\n";
          if ${{ inputs.include }}; then
            echo -e "Total number of included file(s) checked is: ${count2}\n";
          fi;
          echo -e "Scanning Completed!\nCheck-file Exiting!\n .....\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          echo '| Check File Runtime |';
        elif [[ -n $(echo "${file_type}" | grep -E "^c$|^c.$|^c..$|^h$|^h.$|^h..$|^t$|^t.$|^t..$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING C/C++ FILE TYPES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Shell Files
      if: inputs.filename != '' && inputs.database != 'true' && env.FILE_FOUND == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        fixed=false
        shellcheck_count=1
        repaired=$(sudo find ${{ env.FILE_PATH }} -type f -name 'check-file-repaired.txt' -print -quit);
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name ".git" -print -quit);
        repair_file='check-file-repaired.txt';
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        if [[ -n $(echo "${file_type}" | grep -i "^sh$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          if ${{ inputs.content }}; then
            echo -e "\n# Found File Path(s)\n${files}\n";
          fi;
          if [[ -d ${repository} ]] && ${{ inputs.repair }}; then
            repository="${repository%/*}/${repair_file}";
            if [[ -f ${repository} ]]; then
              echo -e "\n####################\nRepaired files list found!!!\n####################\n";
              date >> "${repository}";
            else
              date > "${repository}";
            fi;
          fi;
          (time -p for f in ${files[@]}; do
            SEARCH_PATH="${f}";
            export count3=$((shellcheck_count++));
            echo -e "\n####################\n\tFILE PATH (${count3})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            if ${{ inputs.repair }}; then
              SHELL=SHELLHARDEN
              if ${{ inputs.stored }} && grep -qs "${SEARCH_PATH}" "${repaired}"; then
                echo -e "\n####################\n${SHELL} NOTHING TO REPAIR\n####################\n";
                echo -e "\n####################\n$(basename ${f}) has been checked before skipping\n####################\n";
              elif ${{ inputs.stored }}; then
                echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\n${SHELL} FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                echo "${f}" >> "${repaired}";
                fixed=true
              elif ! ${{ inputs.stored }}; then
                echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
                shellharden --syntax-suggest --transform "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
                if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                  echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
                else
                  echo -e "\n####################\n${SHELL} FOUND ERROR(S) TO REPAIR\n####################\n";
                fi;
                fixed=true
              fi;
            fi;
            if ${{ inputs.recheck }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            elif ! ${{ inputs.repair }}; then
              SHELL=SHELLCHECK
              echo -e "\n\n####################\n${SHELL} ANALYZING $(basename ${f}) FOR ERROR(S) ($count3)\n####################\n\n";
              shellcheck --norc --severity=warning --color=always "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
                echo -e "\n####################\n${SHELL} NO ERRORS FOUND ${f}\n####################\n";
              else
                echo -e "\n####################\n${SHELL} FOUND ERROR(S)\n####################\n";
              fi;
            fi;
            if ${{ inputs.number > 0 }}; then
              if [[ ${{ inputs.number }} -eq ${count1} ]]; then
                echo -e "\nFile ${count1} checking auto stopped at $(basename ${f})\n";
                break;
              fi;
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          if [[ "${fixed}" ]]; then
            echo "FILE_FIXED=1" >> "${GITHUB_ENV}";
          fi;
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count3\n";
          echo -e "Scanning Completed!\nShellTools Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | grep -i "^sh$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING SH FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check Makefile Files
      if: inputs.filename != '' && inputs.database != 'true' && env.FILE_FOUND == 0
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        makefile_count=1
        if [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]] && [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          (time -p for f in ${files[@]}; do
            export count4=$((makefile_count++));
            echo -e "\n####################\n\tFILE PATH (${count4})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
            echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" || >/dev/null;
            if [[ ${PIPESTATUS[0]} == 0 ]] && [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND ${f}\n####################\n";
            else
              echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count4\n";
          echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
        elif [[ -n $(echo "${file_type}" | egrep -i "^mk$|.*Makefile$") ]]; then
          echo -e "\n####################\nFINISHED SEARCHING MK FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Check All Files
      if: inputs.filename != '' && inputs.database != 'true' && env.FILE_FOUND == 0 
      run: |
        export LC_ALL=C
        set -o pipefail
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file_count=1
        if [[ -n ${files} ]]; then
          echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
          echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          time -p for f in ${files[@]}; do
            export count5=$((file_count++));
            echo -e "\n####################\n\tFILE PATH (${count5})\n####################\n";
            echo "$(dirname ${f})";
            if ${{ inputs.content }}; then
              echo -e "\n####################\n\tFILE CONTENT (${count5})\n####################\n\n";
              batcat --theme=ansi --paging=never --show-all --color=always --style=full "${f}";
              echo -e "\n\n";
            fi;
          done) 2>&1;
          echo -n '| Check File Runtime |';
          echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: ${count5}\n";
          echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
        else
          echo -e "\n####################\nFINISHED SEARCHING ALL FILES\nNO ${{ inputs.filename }} FOUND\n####################\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Word Text Match
      if: inputs.filetext != '' && inputs.database != 'false'
      run: |
        export LC_ALL=C
        set -o pipefail
        file_count=1
        echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
        if ${{ inputs.filetype != 'none' }}; then
          for t in ${{ inputs.filetype }}; do
            finder=$(sudo rg "*${t}$" "${{ env.DATABASE }}" | xargs grep --color=always -HFans "${{ inputs.filetext }}");
            content=$(sudo rg "*${t}$" "${{ env.DATABASE }}" | xargs grep --color=always -q "${{ inputs.filetext }}");
            if [[ -n ${finder} ]]; then
              counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
              echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S)\n####################\n";
              echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                  echo -e "\n$(dirname ${c})\n":
                  echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                  batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                  echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
            fi;
          done;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        else
          finder=$(sudo rg -F "*" "${{ env.DATABASE }}" | xargs grep --color=always -HFans "${{ inputs.filetext }}");
          content=$(sudo rg -F "*" "${{ env.DATABASE }}" | xargs grep --color=always -q "${{ inputs.filetext }}");
          if [[ -n ${finder} ]]; then
            counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
            echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN FILE(S)\n####################\n";
            echo -e "\n${finder}\n";
            if ${{ inputs.content }}; then
              for c in ${content[@]}; do
                count=$((file_count++));
                echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                echo -e "\n$(dirname ${c})\n":
                echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                echo -e "\n####################\nFILE COMPLETED\n####################\n";
              done;
            fi;
          else
            echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
          fi;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Word Text Match
      if: inputs.filetext != '' && inputs.database != 'true'
      run: |
        export LC_ALL=C
        set -o pipefail
        file_count=1
        echo -e "\n####################\nWorkspace Folder: ${{ steps.set_dirname.outputs.dirname }}\n####################\n";
        if ${{ inputs.filetype != 'none' }}; then
          for t in ${{ inputs.filetype }}; do
            finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -HFans "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
            content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -q "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
            if [[ -n ${finder} ]]; then
              counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
              echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S)\n####################\n";
              echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                  echo -e "\n$(dirname ${c})\n":
                  echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                  batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                  echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
            fi;
          done;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        else
          finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -HFans "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
          content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -q "${{ inputs.filetext }}" "{}" \; -printf "%p\n");
          if [[ -n ${finder} ]]; then
            counter=$( echo "${finder}" | grep -c "${{ inputs.filetext }}" );
            echo -e "\n####################\n (${counter}) CONTENT MATCH(S) FOUND IN FILE(S)\n####################\n";
            echo -e "\n${finder}\n";
            if ${{ inputs.content }}; then
              for c in ${content[@]}; do
                count=$((file_count++));
                echo -e "\n####################\n\tFILE PATH (${count})\n####################\n";
                echo -e "\n$(dirname ${c})\n":
                echo -e "\n####################\n\tFILE CONTENT (${count})\n####################\n\n";
                batcat --theme=ansi --paging=never --show-all --color=always --style=full "${c}";
                echo -e "\n####################\nFILE COMPLETED\n####################\n";
              done;
            fi;
          else
            echo -e "\n####################\nTEXT MATCH FINISHED SEARCHING\nNO ${{ inputs.filetext }} FOUND\n####################\n";
          fi;
          echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n";
        fi;
      shell: bash
      continue-on-error: true


    - name: Directory Contains
      if: inputs.filename != '' && inputs.content != 'false'
      run: |
        echo ''
        check_file=$(dirname $(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}"));
        file_count=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ steps.set_dirname.outputs.dirname }}/*" -o -path "*" \) | wc -l);
        if [[ ${{ env.FILE_FOUND }} != 0  ]]; then
          echo -e "\n####################\nNOTE: Contents found in directory for ${{ inputs.filename }}\n####################\n";
          ls -Shap "${check_file}";
          echo -e "\n(CLONED REPO) Total Files: ${file_count}\n";
        fi;
      shell: bash
      continue-on-error: true

      
    - name: Repository Update
      if: inputs.update != 'false' && env.FILE_FIXED == 1
      id: changed-files
      run: |
        set -o pipefail
        changed_files=false
        REPAIR_DATE="$(date +%Y%m%d)";
        repository=$(sudo find ${GITHUB_WORKSPACE} -type d -name ".git" -print -quit);
        if [[ -d ${repository} ]]; then
          cd "${repository%/*}";
          git config --global user.name "${{ github.actor }}";
          git config --global user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com";
          git config --global credential.helper store
          git add .
          git commit -m "check-file-action repaired errors in ${{ inputs.filename }} file(s)";
          git push origin "${{ github.ref }}";
          if [[ ${PIPESTATUS[0]} == 0 ]] || [[ ${PIPESTATUS[1]} == 0 ]]; then
            echo -e "\n####################\nCHECK FILE UPDATED REPOSITORY\n####################\n";
            echo -e "\n####################\nUPDATED FILE(S) LIST:\n####################\n";
            git diff --name-only @{push}@{1} @{push} |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
            echo -e "\n\t########## ${REPAIR_DATE} ##########\n";
          else
            echo -e "\n####################\nCHECK FILE COULD NOT UPDATED REPO FILE(S)\n####################\n";
            echo 'Retrying again after git fetches branch';
            git fetch origin "${{ github.ref }}";
            git add .
            git commit -m "check-file-action repaired errors in ${{ inputs.filename }} file(s)";
            git push origin "${{ github.ref }}";
            if [[ ${PIPESTATUS[0]} == 0 ]] || [[ ${PIPESTATUS[1]} == 0 ]]; then
              echo -e "\n####################\nCHECK FILE UPDATED REPOSITORY\n####################\n";
              echo -e "\n####################\nUPDATED FILE(S) LIST:\n####################\n";
              git diff --name-only @{push}@{1} @{push} |& tee -a "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log";
              echo -e "\n\t########## ${REPAIR_DATE} ##########\n";
            else
              echo 'Was git push event successful status ? unknown';
            fi;
          fi;
        else
          echo -e "\n####################\nCHECK FILE CANT FIND (.git) DIR FOR UPDATING\n####################\n";
        fi;
      shell: bash
      continue-on-error: false


    - name: Uploading ${{ inputs.filename }} Error Report
      if: inputs.report != 'false' && inputs.filename != '' && env.FILE_ERROR == 1
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./${{ inputs.filename }}_error.log
        name: Check File Action Errors Report For ${{ inputs.filename }} File(s).
        tag_name: ${{ github.run_id }}


    - name: Delete Log File
      if: inputs.filename != '' || inputs.filetext != ''
      run: |
        date
        if [[ -f "${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log" ]]; then
          echo -e "\nLOGFILE: $(rm -vf ${GITHUB_WORKSPACE}/${{ inputs.filename }}_error.log)\n";
        fi;
        if [[ -f "${GITHUB_WORKSPACE}/check_file_list.txt" ]]; then
          echo -e "\nDATABASE: $(rm -vf ${GITHUB_WORKSPACE}/check_file_list.txt)\n";
        fi;
        echo -e "\n####################\nCHECK FILE EXITING ....\n####################";
      shell: bash
      continue-on-error: false


    - name: Filename Check
      if: inputs.filename == '' && inputs.filetext == ''
      run: |
        echo ''
        echo -e "\nNo input provided!\nVariables not set\n filename\n filetext\n\t Exiting\n";
      shell: bash
      continue-on-error: false

## version v1.1.2 beta